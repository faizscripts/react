the app function is called a react component
it produces jsx and handles user events
it returns jsx which is html content which shows on the screen
jsx can show a normal html element or show react components





??????QUESTION?????? explain how react works and write a line which starts the project
??????QUESTION?????? what are the two react libraries necessary to run a react project and what is their roles
??????QUESTION?????? what is useState



the browser makes a request to the server and it gets back an index.html file which is stored in the public folder, the index file contains scripts which tells the browser to get all the js files i.e app.js, index.js and the react components which are bundled together into a bundle.js file

this js is then converted to html and placed in the index.html file

the first js file that gets executed is index.js which sets up the project.

 it calls the app function <App/> and index.html which contains an ID tag root document.getElementById("root") in this case

ReactDOM.render(<App/>, document.getElementById("root"))

whenever were working with react, we work with two separate libraries i.e React and ReactDOM

React works with components and it's called a reconciler

ReactDOM turns instructions into html and it's called a renderer

useState is a function for working with react's state system. state is used to keep track of data that changes over time. it makes react update the html on the screen




??????QUESTION?????? what are the two possible ways to create a react project
??????QUESTION?????? create a react project called jsx and explain the project structure
??????QUESTION?????? start the react project
??????QUESTION?????? delete all the files in the src folder and make the app display Hello React






we're now going to install a tool called create-react-app which is going to help us set up a new project
~ npm i -g create-react-app

to create a project you now run create-react-app with the name of the project
~ create-react-app projectName


~ npx create-react-app projectName
installs create-react-app and creates a new project in one command


we use create-react-app because it installs for us a ton of dependencies that we don't have to install manually and are important for the running of a react application e.g babel, webpack, dev server


the create-react-app gives us a project structure which consists of the following files

src folder - where we put all the source code we write
public folder - stores static files e.g images
node_modules
package.json
readme


~ npm start
start create-react-app


delete everything in the src folder and create an index.js file


we will use three guidelines in our index.js file
1. import React and ReactDOM libraries
import React from 'react';
import ReactDOM from 'react-dom';

2. create a react component
a react component is a function or a class that produces HTML using JSX and handles feedback from the user using event handlers
const App = () => {
  return <div>Hello React</div>
}

3. show the react component on the screen
ReactDOM.render(<App/>, document.querySelector('#root'))
















??????QUESTION?????? what happens when you start the jsx of the app function on a new line, what is the way around for this for a multiline jsx block
??????QUESTION?????? convert the following piece of code to jsx. also instead of the submit text, create a variable string called click me and pass in the value instead
<div>
    <label for="name" class="label"> Enter name: </label>
    <input id="name" type="text"/>
    <button style="background-color:blue; color:white"> Submit </button>
</div>
??????QUESTION?????? what type of variable doesn't work in jsx


















/// BUILDING CONTENT WITH JSX

jsx gets converted into normal looking js code by babel

jsx is similar to html but it differs in the following ways
1. adding custom styling uses a different syntax
    <div style="background-color:blue;"> </div>
    <div style={{backgroundColor: 'blue'}}> </div>

2. adding a class to an uses a different syntax, for attribute also uses htmlFor
    <label htmlFor="name" className="label"> Enter name: </label>

3. jsx can reference js variables
    {variableName}

///ANSWER
import React from 'react';
import ReactDOM from 'react-dom';

const App = () => {
    const buttonText = 'Click Me!'

  return (
      <div>
        <label htmlFor="name" className="label"> Enter name: </label>
        <input id="name" type="text"/>
        <button style= {{ backgroundColor:'blue', color:'white' }}> {buttonText}</button>
      </div>
  )
}

ReactDOM.render(<App/>, document.querySelector('#root'))



calling an object in the place of text will not work, you will need to reference the keys of the object instead
const buttonText = {text: 'Click me'}

{buttonText} will not work but {buttonText.text} will













??????QUESTION?????? create a react app called components, delete all the files in the src folder and make it print out hello world
??????QUESTION?????? load semantic ui to your project
??????QUESTION?????? add the following jsx in your app function
    <div className="ui container comments">
      <div className="comment">
        <a href="/" className="avatar">
          <img alt="avatar" />
        </a>
        <div className="content">
          <a href="/" className="author">
            Sam
          </a>
          <div className="metadata">
            <span className="date">Today at 6:00PM</span>
          </div>
          <div className="text">Nice blog post!</div>
        </div>
      </div>
    </div>
??????QUESTION?????? use faker to generate random fake images for the avatar of the comment











//// COMMUNICATING WITH PROPS   ////

in this section we're going to focus on 3 things
1. component nesting
2. component reusability
3. component configuration - configure a component when it is created


we're going to create a web app which displays a list of comments


create a new react app called components and delete all the src files

create and index.js file in src and import the necessary libraries and print out Hello world


we're going to use semantic ui for our styling.

google its cdn for the min.css and add it to index.html
an indication that the semantic ui has loaded is that you'll notice that the fonts in your page have changed

add the following jsx in your app function which utilizes semantic ui

    <div className="ui container comments">
      <div className="comment">
        <a href="/" className="avatar">
          <img alt="avatar" />
        </a>
        <div className="content">
          <a href="/" className="author">
            Sam
          </a>
          <div className="metadata">
            <span className="date">Today at 6:00PM</span>
          </div>
          <div className="text">Nice blog post!</div>
        </div>
      </div>
    </div>


we're going to avoid the hustle of downloading and referencing images to save time so instead we'll use a js library called faker.js which generates a massive amount of realistic fake data

~ npm install @faker-js/faker --save-dev

import { faker } from '@faker-js/faker';

<img alt="avatar" src={faker.image.avatar()} />









??????QUESTION?????? execute the most viable way of creating multiple comments and create 3 comments with dynamic authors, time ago, text and image avatar
??????QUESTION?????? create an approval card component which creates a card with an option to approve or reject the comment. style the card using semantic ui cards
??????QUESTION?????? to test reusability of the ApprovalCard, pass some text 'Are you sure' instead of the comment











one way of adding more comments is duplicating the comment code. as you can imagine, this will make the code untidy and difficult to manage


we're going to refactor this code to create reusable components


the series of steps to follow when creating reusable components are
- identify the duplicated jsx
- what is the purpose of the block of jsx? give it a descriptive name
- create a new file to house this component which will have the same name
- create a new component in the file and paste the jsx
- make the new component configurable by using react's props system




in the src folder create a new file called CommentDetail.js. usually react components are written in uppercase


import react and faker then create a function called CommentDetail which you'll paste the comment jsx

in order to use this file inside index.js we will have to export it and import it in index.js


export default CommentDetail;

import CommentDetail from './CommentDetail'

we will then make this component configurable by using reacts prop system


the prop system passes data from a parent component to a child component. the goal is to customize or configure a child component

<CommentDetail author="Sam" />

in the component detail function, the default argument props is an object which contains all the data passed from the parent in key and value pairs. in this case the props object will contain a key of author and the respective value passed by the parent.


this can be destructured at the argument level ({author}) the the variable author called where we were hardcoding the author value

      <a href="/" className="author">
          {author}
      </a>



we're now going to look at props reusability. we're going to create an approval card for the comments where the admin can approve or reject the comments


we'll create another component called approval card which will contain an outline around the comment with two buttons. we will use this together with the CommentDetail component


create ApprovalCard.js inside src folder and add the necessary boilerplate code with card styling from semantic ui

const ApprovalCard = (props) => {
  return (
          <div className="ui card">
              <div className="content">
                  {props.children}
              </div>
              <div className="extra content">
                  <div className="ui two buttons">
                      <div className="ui basic green button">Approve</div>
                      <div className="ui basic red button">Decline</div>
                  </div>
              </div>
          </div>
  )
}


the ApprovalCard component in index.js will have opening and closing tags which will enable us to access the CommentDetail as a child when passed in between the tags


        <ApprovalCard>
            <CommentDetail author={faker.name.findName()} timeAgo="Today at 4.45PM" text="Awesome stuff" avatar={faker.image.avatar()}/>
        </ApprovalCard>


the approval card is reusable and it can even be passed some plain text or html instead of the comment

        <ApprovalCard>Are you sure?</ApprovalCard>

        <ApprovalCard>
            <div>
                <h4>Are you sure in HTML</h4>
            </div>
        </ApprovalCard>













??????QUESTION?????? what are the two different types of components and what is the difference between them
??????QUESTION?????? create a new react project called seasons, link up semantic ui to the project
??????QUESTION?????? for starting, we will use two function based components. create an App component which prints out Hello World and a SeasonDisplay component which prints out Seasons






//////  STRUCTURING APPS WITH CLASS BASED COMPONENTS    ///














there are two types of components, function and class components


functional components
1. can produce jsx to show content to the user
2. can use hooks to run code at specific points in time
3. can use hooks to access state system and update content on screen
4. good for simple content


class components
1. can produce jsx to show content to the user
2. can use lifecycle method system to run code at specific points in time
3. can use the state system to update content on the screen
4. good for just about everything else


if both components have almost the same capabilities, it begs the question, which one should we use


old projects most likey run with class based components as function based components had restricted use in the past


newer projects may be using class based or function based components


we're going to create a simple react app to understand this. the app is going to check the users location and month then print the season the user is currently experiencing


create a new project called seasons and link it up with semantic ui


delete files in src and create index.js


for starting we will have two components, an app component which has code to determine location + month and a seasons display component which shows different text/ icons based on props


in the index.js write the necessary boilerplate code and print Hello World


also create another file called SeasonDisplay.js which prints out season








??????QUESTION?????? use window.navigator.geolocation.getCurrentPosition() to get the users location. it accepts two callback functions, use them to console log the result and the error
??????QUESTION?????? what is the issue of using a function based component with this call back function











we're now going to look at how to get the users physical location using functions that are build into most morder browsers


this is Geolocation API


    window.navigator.geolocation.getCurrentPosition(
        position => console.log(position),
        positionError => console.log(positionError)
    )
gets the location, however it takes time so you'll have to use a callback function


add this to your App function


the getting location function takes some time to execute. however our function will continue execution and return jsx which will make it impossible to get back to our callback function














??????QUESTION?????? what are the 3 rules of a class based component
??????QUESTION?????? initialize the state system which will have a property lat
??????QUESTION?????? why do we use the super function
??????QUESTION?????? how can you access the values in your state













one way around this is using class based components and react state system where once after getting the result of the geolocation we will tell the app to rerender itself with this new information


a class based component follows the following rules
1. must be a js class
2, must extend React.Component class
3. must define a render method that returns some amount of jsx


class App extends React.Component{
    render(){
        return <div>This is a class based component</div>
    }
}


we extend from react component because react expects several other methods attached to it in order to work. however we don't have to create all of these therefore we borrow them from the React.Component class


in order to access the data from the callback which takes time to execute, we will use the state system


rules of the state system
1. only usable with class components (*might technically be used with functional components but this will be further discussed later)
2. don't confuse props with state
3. state is a js object that contains data relevant to a component
4. state must be initialized when a component is created
5. updating state on a component causes the component to (almost) instantly rerender
6. state can only be updated using the function setState




in order to initialize state when our component is created, we will use a constructor function which normally is the first function called in a class


there are other ways of initializing a state but for now we will just start with this constructor way


the constructor method will be automatically called with the props object


~ super(props)
we will then call a function called super which is borrowed from the parent class React.Component and pass the props. this will make sure that the constructor method in the parent class is called


~ this.state = { lat: null }
this will initialize the state and since we know before hand that we will be using the latitude value from our callback function, we will create a property lat and set its value to null



    constructor(props) {
        super(props);

        this.state = { lat: null}
    }


~ {this.state.null}
after initializing the state, we can access it from anywhere inside our class based component












??????QUESTION?????? refactor the getting latitude function so that it doesn't get called everytime our component is rendered. why is this refactor important
??????QUESTION?????? update the value of state to the latitude result of the callback and print it out on the screen
??????QUESTION?????? create another property of our state called errorMessage. in the case an error occurs update the value of errorMessage to store the error from the callback
??????QUESTION?????? edit the render function to print the latitude value if its present, the error message if an error occurred or loading is the results haven't been fetched yet




















if we update our state after we get the results from our callback function, this will make the component to rerender and we will be able to access the latitude value



note that the rerendering will cause the getCurrentPosition function to be called all the time. due to this we will move it to our constructor so that it is called when the component is created for the first time and avoid the repetition



~ this.setState({lat: position.coords.latitude})
we will also update our state to get the value of latitude from our callback function. the console log isn't necessary at this point



create another property of our state called errorMessage. in the case an error occurs update the value of errorMessage to store the error from the callback

~ this.state = { lat: null, errorMessage: ''}

~   positionError => {
         this.setState({errorMessage: positionError.message})
    }


edit the render function, add a new line which prints out the value of the error message

~    render() {
         return (
             <div>
                 Latitude: {this.state.lat}
                 <br/>
                 Error: {this.state.errorMessage}
             </div>
         )
     }



the code now works well, however printing out the word error all the time doesn't look good


we will look at the scenarios that can occur with our latitude situation
1. have latitude, no errorMessage   - show latitude
1. no latitude, have errorMessage   - show errorMessage
1. no latitude, no errorMessage     - show loading...



we can implement this using an if statement in our render function

   render() {
        if (this.state.errorMessage && !this.state.lat){
            return <div>Error: {this.state.errorMessage}</div>
        } else if (!this.state.errorMessage && this.state.lat){
            return <div>Latitude: {this.state.lat}</div>
        } else return <div>Loading...</div>
   }














??????QUESTION?????? describe the component lifecycle with all the methods associated to it. explain what the methods are used for
??????QUESTION?????? do all the data loading in the componentDidMount method
??????QUESTION?????? use the alternative way of initialzing the state











we're going to refactor our code and initialize our state using an alternative way


in order to do this we need to understand life cycle methods


-the component starts with a constructor then the render method is called. the content now becomes visible on the screen. in the render method, avoid doing anything besides returning jsx
- a componentDidMount function is then automatically called, this is called once when our component is rendered on the screen for the first time. this is a good place to do data loading
- our component will now sit and wait for updates
- when an update happens on our state, the component is rerendered and a componentDidUpdate function is called automatically. this is a good place to do more data loading when state/ props change
- this update cycle is then repeated until the component is no longer shown where a componentWillUnmount function will be automatically called. this is a good place to do clean up especially for non react stuff


there are 3 other lifecycle methods but they're rarely used
1. shouldComponentUpdate
2. getDerivedStateFromProps
3. getSnapshotBeforeUpdate


in our case, we can execute the getting current position in our constructor and our componentDidMount methods. however it is a good practise to do your data loading in the componentDidMount method which is what we're going to do. we will refactor our code this way


componentDidMount() {
        window.navigator.geolocation.getCurrentPosition(
            position => {
                this.setState({lat: position.coords.latitude})
            },
            positionError => {
                this.setState({errorMessage: positionError.message})
            }
        )
    }


with this refactor, the job of our constructor now is to only initialize the state. due to this, we can use the alternative initializing state method

~ state = {lat: null, errorMessage:''}













??????QUESTION?????? display 'Burr it's chilly' if its winter or 'Let's hit the beach' if summer based on the latitude and month using the function below
const getSeason = (lat, month) => {
  if (month>2 && month <9){
    return lat > 0 ? 'summer' : 'winter'
  } else return lat > 0 ? 'winter' : 'summer'
}
??????QUESTION?????? make the text displayed large











moving on with the app, we want to display the season to the user instead of the latitude


~ import SeasonDisplay from "./SeasonDisplay";

in the render function of our class, we will replace where we were printing out the latitude with the SeasonDisplay component. we will also pass the latitude from the state as a prop

~ else if (!this.state.errorMessage && this.state.lat{
        return <SeasonDisplay lat={this.state.lat} />
    }


we will now move on to logic for finding the season based on our latitude and month


in SeasonDisplay.js, we will create a function called getSeason outside the SeasonDisplay component. this is a good practice as we should write all the logic of our code outside the functional component code


const getSeason = (lat, month) => {
  if (month>2 && month <9){
    return lat > 0 ? 'summer' : 'winter'
  } else return lat > 0 ? 'winter' : 'summer'
}


we will call this function in our SeasonDisplay component and based on the season print some text to show the season

const SeasonDisplay = (props) => {

  const season = getSeason(props.lat, new Date().getMonth())
  const text = season === 'summer' ? "Let's hit the beach!" : "Burr, it's chilly!"

  return (
      <div>
        <h1>{text}</h1>
      </div>
  )
}













??????QUESTION?????? add snowflake or sun icons from semantic ui before and after the text. refactor the code to avoid repetition when checking for the season and what to display
??????QUESTION?????? make the icons you've added big













we will then add some icons from semantic ui to show the season. this will mean that we create another ternary operator which makes the code kind of repetitive


to counter this, we will create an object with summer and winter properties whose values will be the properties of of the respective season


we will give the exact names summer and winter as keys so that it becomes easy to reference the keys


we will also destructure this and save them in variables

const seasonConfig = {
    summer: {
        text: `Let's go to the beach`,
        iconName: 'sun'
    },
    winter: {
        text: `Burr, it's chilly`,
        iconName: 'snowflake'
    }
}


const SeasonDisplay = (props) => {

    const season = getSeason(props.lat, new Date().getMonth())

    const {text, iconName} = seasonConfig[season]

    return (
        <div>
            <i className={`massive ${iconName} icon`}/>
            <h1>{text}</h1>
            <i className={`massive ${iconName} icon`}/>
        </div>
    )
}














??????QUESTION?????? create a SeasonDisplay.css file and place the first icon top left and second icon bottom right. center the text
??????QUESTION?????? add the following styles too
                        winter          summer
background colour       aquablue        orange
icon                    blue            red













we're now going to add some styling, inside the src folder create a css file called SeasonDisplay.css


we'll add icon-left and icon-right class to the icons then use positioning to position them top left and bottom right respectively


.icon-left{
    position: absolute;
    top: 10px;
    left: 10px;
}

.icon-right{
    position: absolute;
    bottom: 10px;
    right: 10px;
}



we will then import this css file in SeasonDisplay.js



we're going to have a theme based on the season, blue for winter and orange for summer. to do this we'll add a class to the first div of our SeasonDisplay component.

<div className={`season-display ${season}`}>


center the text and add the background color by adding the following css

.season-display{
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
}

.winter{
    background-color: aliceblue;
}

.summer{
    background-color: orange;
}

.season-display.winter i{
    color: blue;
}

.season-display.summer i{
    color: red;
}










??????QUESTION?????? create a component called spinner using semantic ui and use it instead of the loading text while waiting for the use to give permission to access their location
??????QUESTION?????? make the spinner dynamic and pass in custom text. also make it show default text loading... in the case custom text is not passed
??????QUESTION?????? reformat the conditional code in the render function in index.js and place it in a separate function
















we're now going to create a component for showing the loader


create Spinner.js and get the spinner code from semantic ui

import React from "react";

const Spinner = () => {
    return (
        <div className="ui active inverted dimmer">
            <div className="ui big text loader">
                Loading...
            </div>
        </div>
    )
}

export default Spinner


import this and use it instead of the loading text



we will then make this dynamic and pass the text we want to show in the app component.


this makes it reusable, however it will be even much better if we could add some default text in the case where the message isn't passed when the component is referenced


we'll do this by setting a default value for the prop

Spinner.defaultProps ={
    message: 'Loading...'
}



our code is now looking good, however there's one improvement that we can make



in our index.js render has conditional code, this makes the code rigid in the case we want to make changes in future


the goal is to have a return statement in our render function


we will transfer the conditional code in a separate function and pass the function in our render function

note the use of this when refering to the renderContent method inside the render function

    renderContent(){
        if (this.state.errorMessage && !this.state.lat){
            return <div>Error: {this.state.errorMessage}</div>
        } else if (!this.state.errorMessage && this.state.lat){
            return <SeasonDisplay lat={this.state.lat} />
        } else return <Spinner message="Please accept location request"/>
    }

    render() {
        return(
            <div>
                {this.renderContent()}
            </div>
        )
   }




































































