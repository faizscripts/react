the app function is called a react component
it produces jsx and handles user events
it returns jsx which is html content which shows on the screen
jsx can show a normal html element or show react components





??????QUESTION?????? explain how react works and write a line which starts the project
??????QUESTION?????? what are the two react libraries necessary to run a react project and what is their roles
??????QUESTION?????? what is useState



the browser makes a request to the server and it gets back an index.html file which is stored in the public folder, the index file contains scripts which tells the browser to get all the js files i.e app.js, index.js and the react components which are bundled together into a bundle.js file

this js is then converted to html and placed in the index.html file

the first js file that gets executed is index.js which sets up the project.

 it calls the app function <App/> and index.html which contains an ID tag root document.getElementById("root") in this case

ReactDOM.render(<App/>, document.getElementById("root"))

whenever were working with react, we work with two separate libraries i.e React and ReactDOM

React works with components and it's called a reconciler

ReactDOM turns instructions into html and it's called a renderer

useState is a function for working with react's state system. state is used to keep track of data that changes over time. it makes react update the html on the screen




??????QUESTION?????? what are the two possible ways to create a react project
??????QUESTION?????? create a react project called jsx and explain the project structure
??????QUESTION?????? start the react project
??????QUESTION?????? delete all the files in the src folder and make the app display Hello React






we're now going to install a tool called create-react-app which is going to help us set up a new project
~ npm i -g create-react-app

to create a project you now run create-react-app with the name of the project
~ create-react-app projectName


~ npx create-react-app projectName
installs create-react-app and creates a new project in one command


we use create-react-app because it installs for us a ton of dependencies that we don't have to install manually and are important for the running of a react application e.g babel, webpack, dev server


the create-react-app gives us a project structure which consists of the following files

src folder - where we put all the source code we write
public folder - stores static files e.g images
node_modules
package.json
readme


~ npm start
start create-react-app


delete everything in the src folder and create an index.js file


we will use three guidelines in our index.js file
1. import React and ReactDOM libraries
import React from 'react';
import ReactDOM from 'react-dom';

2. create a react component
a react component is a function or a class that produces HTML using JSX and handles feedback from the user using event handlers
const App = () => {
  return <div>Hello React</div>
}

3. show the react component on the screen
ReactDOM.render(<App/>, document.querySelector('#root'))
















??????QUESTION?????? what happens when you start the jsx of the app function on a new line, what is the way around for this for a multiline jsx block
??????QUESTION?????? convert the following piece of code to jsx. also instead of the submit text, create a variable string called click me and pass in the value instead
<div>
    <label for="name" class="label"> Enter name: </label>
    <input id="name" type="text"/>
    <button style="background-color:blue; color:white"> Submit </button>
</div>
??????QUESTION?????? what type of variable doesn't work in jsx


















/// BUILDING CONTENT WITH JSX

jsx gets converted into normal looking js code by babel

jsx is similar to html but it differs in the following ways
1. adding custom styling uses a different syntax
    <div style="background-color:blue;"> </div>
    <div style={{backgroundColor: 'blue'}}> </div>

2. adding a class to an uses a different syntax, for attribute also uses htmlFor
    <label htmlFor="name" className="label"> Enter name: </label>

3. jsx can reference js variables
    {variableName}

///ANSWER
import React from 'react';
import ReactDOM from 'react-dom';

const App = () => {
    const buttonText = 'Click Me!'

  return (
      <div>
        <label htmlFor="name" className="label"> Enter name: </label>
        <input id="name" type="text"/>
        <button style= {{ backgroundColor:'blue', color:'white' }}> {buttonText}</button>
      </div>
  )
}

ReactDOM.render(<App/>, document.querySelector('#root'))



calling an object in the place of text will not work, you will need to reference the keys of the object instead
const buttonText = {text: 'Click me'}

{buttonText} will not work but {buttonText.text} will













??????QUESTION?????? create a react app called components, delete all the files in the src folder and make it print out hello world
??????QUESTION?????? load semantic ui to your project
??????QUESTION?????? add the following jsx in your app function
    <div className="ui container comments">
      <div className="comment">
        <a href="/" className="avatar">
          <img alt="avatar" />
        </a>
        <div className="content">
          <a href="/" className="author">
            Sam
          </a>
          <div className="metadata">
            <span className="date">Today at 6:00PM</span>
          </div>
          <div className="text">Nice blog post!</div>
        </div>
      </div>
    </div>
??????QUESTION?????? use faker to generate random fake images for the avatar of the comment











//// COMMUNICATING WITH PROPS   ////

in this section we're going to focus on 3 things
1. component nesting
2. component reusability
3. component configuration - configure a component when it is created


we're going to create a web app which displays a list of comments


create a new react app called components and delete all the src files

create and index.js file in src and import the necessary libraries and print out Hello world


we're going to use semantic ui for our styling.

google its cdn for the min.css and add it to index.html
an indication that the semantic ui has loaded is that you'll notice that the fonts in your page have changed

add the following jsx in your app function which utilizes semantic ui

    <div className="ui container comments">
      <div className="comment">
        <a href="/" className="avatar">
          <img alt="avatar" />
        </a>
        <div className="content">
          <a href="/" className="author">
            Sam
          </a>
          <div className="metadata">
            <span className="date">Today at 6:00PM</span>
          </div>
          <div className="text">Nice blog post!</div>
        </div>
      </div>
    </div>


we're going to avoid the hustle of downloading and referencing images to save time so instead we'll use a js library called faker.js which generates a massive amount of realistic fake data

~ npm install @faker-js/faker --save-dev

import { faker } from '@faker-js/faker';

<img alt="avatar" src={faker.image.avatar()} />









??????QUESTION?????? execute the most viable way of creating multiple comments and create 3 comments with dynamic authors, time ago, text and image avatar
??????QUESTION?????? create an approval card component which creates a card with an option to approve or reject the comment. style the card using semantic ui cards
??????QUESTION?????? to test reusability of the ApprovalCard, pass some text 'Are you sure' instead of the comment











one way of adding more comments is duplicating the comment code. as you can imagine, this will make the code untidy and difficult to manage


we're going to refactor this code to create reusable components


the series of steps to follow when creating reusable components are
- identify the duplicated jsx
- what is the purpose of the block of jsx? give it a descriptive name
- create a new file to house this component which will have the same name
- create a new component in the file and paste the jsx
- make the new component configurable by using react's props system




in the src folder create a new file called CommentDetail.js. usually react components are written in uppercase


import react and faker then create a function called CommentDetail which you'll paste the comment jsx

in order to use this file inside index.js we will have to export it and import it in index.js


export default CommentDetail;

import CommentDetail from './CommentDetail'

we will then make this component configurable by using reacts prop system


the prop system passes data from a parent component to a child component. the goal is to customize or configure a child component

<CommentDetail author="Sam" />

in the component detail function, the default argument props is an object which contains all the data passed from the parent in key and value pairs. in this case the props object will contain a key of author and the respective value passed by the parent.


this can be destructured at the argument level ({author}) the the variable author called where we were hardcoding the author value

      <a href="/" className="author">
          {author}
      </a>



we're now going to look at props reusability. we're going to create an approval card for the comments where the admin can approve or reject the comments


we'll create another component called approval card which will contain an outline around the comment with two buttons. we will use this together with the CommentDetail component


create ApprovalCard.js inside src folder and add the necessary boilerplate code with card styling from semantic ui

const ApprovalCard = (props) => {
  return (
          <div className="ui card">
              <div className="content">
                  {props.children}
              </div>
              <div className="extra content">
                  <div className="ui two buttons">
                      <div className="ui basic green button">Approve</div>
                      <div className="ui basic red button">Decline</div>
                  </div>
              </div>
          </div>
  )
}


the ApprovalCard component in index.js will have opening and closing tags which will enable us to access the CommentDetail as a child when passed in between the tags


        <ApprovalCard>
            <CommentDetail author={faker.name.findName()} timeAgo="Today at 4.45PM" text="Awesome stuff" avatar={faker.image.avatar()}/>
        </ApprovalCard>


the approval card is reusable and it can even be passed some plain text or html instead of the comment

        <ApprovalCard>Are you sure?</ApprovalCard>

        <ApprovalCard>
            <div>
                <h4>Are you sure in HTML</h4>
            </div>
        </ApprovalCard>













??????QUESTION?????? what are the two different types of components and what is the difference between them
??????QUESTION?????? create a new react project called seasons, link up semantic ui to the project
??????QUESTION?????? for starting, we will use two function based components. create an App component which prints out Hello World and a SeasonDisplay component which prints out Seasons






//////  STRUCTURING APPS WITH CLASS BASED COMPONENTS    ///














there are two types of components, function and class components


functional components
1. can produce jsx to show content to the user
2. can use hooks to run code at specific points in time
3. can use hooks to access state system and update content on screen
4. good for simple content


class components
1. can produce jsx to show content to the user
2. can use lifecycle method system to run code at specific points in time
3. can use the state system to update content on the screen
4. good for just about everything else


if both components have almost the same capabilities, it begs the question, which one should we use


old projects most likey run with class based components as function based components had restricted use in the past


newer projects may be using class based or function based components


we're going to create a simple react app to understand this. the app is going to check the users location and month then print the season the user is currently experiencing


create a new project called seasons and link it up with semantic ui


delete files in src and create index.js


for starting we will have two components, an app component which has code to determine location + month and a seasons display component which shows different text/ icons based on props


in the index.js write the necessary boilerplate code and print Hello World


also create another file called SeasonDisplay.js which prints out season








??????QUESTION?????? use window.navigator.geolocation.getCurrentPosition() to get the users location. it accepts two callback functions, use them to console log the result and the error
??????QUESTION?????? what is the issue of using a function based component with this call back function











we're now going to look at how to get the users physical location using functions that are build into most morder browsers


this is Geolocation API


    window.navigator.geolocation.getCurrentPosition(
        position => console.log(position),
        positionError => console.log(positionError)
    )
gets the location, however it takes time so you'll have to use a callback function


add this to your App function


the getting location function takes some time to execute. however our function will continue execution and return jsx which will make it impossible to get back to our callback function














??????QUESTION?????? what are the 3 rules of a class based component
??????QUESTION?????? initialize the state system which will have a property lat
??????QUESTION?????? why do we use the super function
??????QUESTION?????? how can you access the values in your state













one way around this is using class based components and react state system where once after getting the result of the geolocation we will tell the app to rerender itself with this new information


a class based component follows the following rules
1. must be a js class
2, must extend React.Component class
3. must define a render method that returns some amount of jsx


class App extends React.Component{
    render(){
        return <div>This is a class based component</div>
    }
}


we extend from react component because react expects several other methods attached to it in order to work. however we don't have to create all of these therefore we borrow them from the React.Component class


in order to access the data from the callback which takes time to execute, we will use the state system


rules of the state system
1. only usable with class components (*might technically be used with functional components but this will be further discussed later)
2. don't confuse props with state
3. state is a js object that contains data relevant to a component
4. state must be initialized when a component is created
5. updating state on a component causes the component to (almost) instantly rerender
6. state can only be updated using the function setState




in order to initialize state when our component is created, we will use a constructor function which normally is the first function called in a class


there are other ways of initializing a state but for now we will just start with this constructor way


the constructor method will be automatically called with the props object


~ super(props)
we will then call a function called super which is borrowed from the parent class React.Component and pass the props. this will make sure that the constructor method in the parent class is called


~ this.state = { lat: null }
this will initialize the state and since we know before hand that we will be using the latitude value from our callback function, we will create a property lat and set its value to null



    constructor(props) {
        super(props);

        this.state = { lat: null}
    }


~ {this.state.null}
after initializing the state, we can access it from anywhere inside our class based component












??????QUESTION?????? refactor the getting latitude function so that it doesn't get called everytime our component is rendered. why is this refactor important
??????QUESTION?????? update the value of state to the latitude result of the callback and print it out on the screen
??????QUESTION?????? create another property of our state called errorMessage. in the case an error occurs update the value of errorMessage to store the error from the callback
??????QUESTION?????? edit the render function to print the latitude value if its present, the error message if an error occurred or loading is the results haven't been fetched yet




















if we update our state after we get the results from our callback function, this will make the component to rerender and we will be able to access the latitude value



note that the rerendering will cause the getCurrentPosition function to be called all the time. due to this we will move it to our constructor so that it is called when the component is created for the first time and avoid the repetition



~ this.setState({lat: position.coords.latitude})
we will also update our state to get the value of latitude from our callback function. the console log isn't necessary at this point



create another property of our state called errorMessage. in the case an error occurs update the value of errorMessage to store the error from the callback

~ this.state = { lat: null, errorMessage: ''}

~   positionError => {
         this.setState({errorMessage: positionError.message})
    }


edit the render function, add a new line which prints out the value of the error message

~    render() {
         return (
             <div>
                 Latitude: {this.state.lat}
                 <br/>
                 Error: {this.state.errorMessage}
             </div>
         )
     }



the code now works well, however printing out the word error all the time doesn't look good


we will look at the scenarios that can occur with our latitude situation
1. have latitude, no errorMessage   - show latitude
1. no latitude, have errorMessage   - show errorMessage
1. no latitude, no errorMessage     - show loading...



we can implement this using an if statement in our render function

   render() {
        if (this.state.errorMessage && !this.state.lat){
            return <div>Error: {this.state.errorMessage}</div>
        } else if (!this.state.errorMessage && this.state.lat){
            return <div>Latitude: {this.state.lat}</div>
        } else return <div>Loading...</div>
   }














??????QUESTION?????? describe the component lifecycle with all the methods associated to it. explain what the methods are used for
??????QUESTION?????? do all the data loading in the componentDidMount method
??????QUESTION?????? use the alternative way of initializing the state












we're going to refactor our code and initialize our state using an alternative way


in order to do this we need to understand life cycle methods


-the component starts with a constructor then the render method is called. the content now becomes visible on the screen. in the render method, avoid doing anything besides returning jsx
- a componentDidMount function is then automatically called, this is called once when our component is rendered on the screen for the first time. this is a good place to do data loading
- our component will now sit and wait for updates
- when an update happens on our state, the component is rerendered and a componentDidUpdate function is called automatically. this is a good place to do more data loading when state/ props change
- this update cycle is then repeated until the component is no longer shown where a componentWillUnmount function will be automatically called. this is a good place to do clean up especially for non react stuff


there are 3 other lifecycle methods but they're rarely used
1. shouldComponentUpdate
2. getDerivedStateFromProps
3. getSnapshotBeforeUpdate


in our case, we can execute the getting current position in our constructor and our componentDidMount methods. however it is a good practise to do your data loading in the componentDidMount method which is what we're going to do. we will refactor our code this way


componentDidMount() {
        window.navigator.geolocation.getCurrentPosition(
            position => {
                this.setState({lat: position.coords.latitude})
            },
            positionError => {
                this.setState({errorMessage: positionError.message})
            }
        )
    }


with this refactor, the job of our constructor now is to only initialize the state. due to this, we can use the alternative initializing state method

~ state = {lat: null, errorMessage:''}













??????QUESTION?????? display 'Burr it's chilly' if its winter or 'Let's hit the beach' if summer based on the latitude and month using the function below
const getSeason = (lat, month) => {
  if (month>2 && month <9){
    return lat > 0 ? 'summer' : 'winter'
  } else return lat > 0 ? 'winter' : 'summer'
}
??????QUESTION?????? make the text displayed large











moving on with the app, we want to display the season to the user instead of the latitude


~ import SeasonDisplay from "./SeasonDisplay";

in the render function of our class, we will replace where we were printing out the latitude with the SeasonDisplay component. we will also pass the latitude from the state as a prop

~ else if (!this.state.errorMessage && this.state.lat{
        return <SeasonDisplay lat={this.state.lat} />
    }


we will now move on to logic for finding the season based on our latitude and month


in SeasonDisplay.js, we will create a function called getSeason outside the SeasonDisplay component. this is a good practice as we should write all the logic of our code outside the functional component code


const getSeason = (lat, month) => {
  if (month>2 && month <9){
    return lat > 0 ? 'summer' : 'winter'
  } else return lat > 0 ? 'winter' : 'summer'
}


we will call this function in our SeasonDisplay component and based on the season print some text to show the season

const SeasonDisplay = (props) => {

  const season = getSeason(props.lat, new Date().getMonth())
  const text = season === 'summer' ? "Let's hit the beach!" : "Burr, it's chilly!"

  return (
      <div>
        <h1>{text}</h1>
      </div>
  )
}













??????QUESTION?????? add snowflake or sun icons from semantic ui before and after the text. refactor the code to avoid repetition when checking for the season and what to display
??????QUESTION?????? make the icons you've added big













we will then add some icons from semantic ui to show the season. this will mean that we create another ternary operator which makes the code kind of repetitive


to counter this, we will create an object with summer and winter properties whose values will be the properties of of the respective season


we will give the exact names summer and winter as keys so that it becomes easy to reference the keys


we will also destructure this and save them in variables

const seasonConfig = {
    summer: {
        text: `Let's go to the beach`,
        iconName: 'sun'
    },
    winter: {
        text: `Burr, it's chilly`,
        iconName: 'snowflake'
    }
}


const SeasonDisplay = (props) => {

    const season = getSeason(props.lat, new Date().getMonth())

    const {text, iconName} = seasonConfig[season]

    return (
        <div>
            <i className={`massive ${iconName} icon`}/>
            <h1>{text}</h1>
            <i className={`massive ${iconName} icon`}/>
        </div>
    )
}














??????QUESTION?????? create a SeasonDisplay.css file and place the first icon top left and second icon bottom right. center the text
??????QUESTION?????? add the following styles too
                        winter          summer
background colour       aquablue        orange
icon                    blue            red













we're now going to add some styling, inside the src folder create a css file called SeasonDisplay.css


we'll add icon-left and icon-right class to the icons then use positioning to position them top left and bottom right respectively


.icon-left{
    position: absolute;
    top: 10px;
    left: 10px;
}

.icon-right{
    position: absolute;
    bottom: 10px;
    right: 10px;
}



we will then import this css file in SeasonDisplay.js



we're going to have a theme based on the season, blue for winter and orange for summer. to do this we'll add a class to the first div of our SeasonDisplay component.

<div className={`season-display ${season}`}>


center the text and add the background color by adding the following css

.season-display{
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
}

.winter{
    background-color: aliceblue;
}

.summer{
    background-color: orange;
}

.season-display.winter i{
    color: blue;
}

.season-display.summer i{
    color: red;
}










??????QUESTION?????? create a component called spinner using semantic ui and use it instead of the loading text while waiting for the use to give permission to access their location
??????QUESTION?????? make the spinner dynamic and pass in custom text. also make it show default text loading... in the case custom text is not passed
??????QUESTION?????? reformat the conditional code in the render function in index.js and place it in a separate function
















we're now going to create a component for showing the loader


create Spinner.js and get the spinner code from semantic ui

import React from "react";

const Spinner = () => {
    return (
        <div className="ui active inverted dimmer">
            <div className="ui big text loader">
                Loading...
            </div>
        </div>
    )
}

export default Spinner


import this and use it instead of the loading text



we will then make this dynamic and pass the text we want to show in the app component.


this makes it reusable, however it will be even much better if we could add some default text in the case where the message isn't passed when the component is referenced


we'll do this by setting a default value for the prop

Spinner.defaultProps ={
    message: 'Loading...'
}



our code is now looking good, however there's one improvement that we can make



in our index.js render has conditional code, this makes the code rigid in the case we want to make changes in future


the goal is to have a return statement in our render function


we will transfer the conditional code in a separate function and pass the function in our render function

note the use of this when refering to the renderContent method inside the render function

    renderContent(){
        if (this.state.errorMessage && !this.state.lat){
            return <div>Error: {this.state.errorMessage}</div>
        } else if (!this.state.errorMessage && this.state.lat){
            return <SeasonDisplay lat={this.state.lat} />
        } else return <Spinner message="Please accept location request"/>
    }

    render() {
        return(
            <div>
                {this.renderContent()}
            </div>
        )
   }

















??????QUESTION?????? create a new react project called pics
??????QUESTION?????? do a more organized component set up and print out app
??????QUESTION?????? create another component called search bar which will be used to handle the user input. this should guide you on which type of component to create. the app should print a text input from the search bar component instead of the previous text
??????QUESTION?????? add semantic ui to the project
??????QUESTION?????? do the following styling for the SearchBar component
        <div className="ui segment">
            <form className="ui form">
                <label>Image Search</label>
                <input type="text"/>
            </form>
        </div>
??????QUESTION?????? add the following styling to the App component
      <div className="ui container" style={{marginTop: '10px'}}>
        <SearchBar />
      </div>
















///////  HANDLING USER INPUTS WITH FORMS AND EVENTS ///////

create a new react app called pics


our app is going to get a search term from the user, use an api to fetch images related to that search term then display those images on the screen



we'll create a SearchBar component that is responsible for showing a text input at the very top of the screen


we'll also have a second component called the ImageList which will take a list of images and render them out


go inside the pics app we created, delete all the src files and create an index.js file as usual



this time we'll have something different instead of our usual boilerplate code in index.js


we know before hand that we'll have several components and several css files. with this in mind the src folder might get a little messy


we'll create a folder called components where we'll store all our components including the App component


in the components folder create App.js which will print out App. export it and import it in index.js


render the App component in index.js



now create a new component called SearchBar in the components folder


this will show the input and we know that this will be a class based component as we know we'll have to use state to handle the user input


for now we'll just make it return a input text element wrapped inside a form, export and import in App component rather than showing the App text



we'll now do some styling using semantic ui. add the cdn in index.html


add the following classes to the search bar component
        <div className="ui segment">
            <form className="ui form">
                <label>Image Search</label>
                <input type="text"/>
            </form>
        </div>


do the following styling in the app component
      <div className="ui container" style={{marginTop: '10px'}}>
        <SearchBar />
      </div>















??????QUESTION?????? add a function called onInputChange which detects when a user enters some input and console log it
??????QUESTION?????? what is the alternate syntax for handling the onChange prop and when is it used











we're now going to add some event handlers to detect when a user enters some input


in the SearchBar component, we'll create an onInputChange function which will be called when there's an input change. this is possible by adding this function as a prop to onChange={this.onInputChange}


note that despite on inputChange being a function, we do not call it i.e. onInputChange() as this will run the function everytime the component is rendered. we dont put the call () and leave the function to be called only when there's an input change


this callback will be run with the event argument passed to it automatically


the property that we care the most about is event.target.value which will contain the text that the user added to the input


other similar props to onChange include onClick and onSubmit




we'll refactor our code to use an alternate event handling syntax


this is mostly used when our event handling is a single line of code. in this case we're only console logging the event.target.value therefore it can be a good use case


you basically write the function inside the jsx
~ onChange={ e => console.log(e.target.value) }













??????QUESTION?????? what is the difference between controlled elements and uncontrolled elements
??????QUESTION?????? convert the input element to a controlled element














there are two types of elements which we do event handling on, controlled elements which is what most react developers prefer using and uncontrolled elements which is like the input element we're currently using


we'll refactor our code and convert the element from uncontrolled to controlled


delete the onInputChange function. initialize state which will have a property called term which will default into an empty string

~ state = { term: '' }


we'll then modify our onChange prop, do an inline arrow function and setState term to the value entered by the user

~ onChange = { e => this.setState{ term: e.target.value }}


we'll also add a new prop on the input element called value which we'll set to term from the state
~ value = {this.state.term}


the flow of our app now is
- user types in input
- callback gets invoked
- we setState with the new value
- component rerenders
- input value is updated to the updated value from state


this is what constitutes a controlled element


for the uncontrolled element, react has no idea on what the value of the input is as much as it's available in html. the only way we can access the input value in react is if we reach out to the dom and pull the value


storing information inside html is not a good practise that's why we use controlled elements which centralizes the information in the react world



onChange={event => this.setState({password: event.target.value})}
value = {this.state.password}










??????QUESTION?????? what is the default behaviour when a user submits the form
??????QUESTION?????? prevent this default behaviour
??????QUESTION?????? console log the value in the onFormSubmit function
??????QUESTION?????? what are the two ways you can use to solve the this error in a class component












our SearchBar now knows what the user is typing. we will now start working on submitting


we will need to figure out when the submission is made or in other terms when the user presses the enter key


for now when we press enter, the default behaviour of the browser is to try and submit the form to a backend server of sorts


we don't have a backend server so in this case the page will kind of refresh and our input will be lost


we want to stop this default behaviour and instead run some custom logic of our own


create an onSubmit prop in the form element which will call onFormSubmit method
~ onSubmit={this.onFormSubmit}

create this onFormSubmit method and first disable the default behaviour
~   onFormSubmit(event){
        event.preventDefault();
    }




if we try and console log the value of term from the state, we will be met with an error
Cannot read properties of undefined (reading 'state')


this is because the value of this changes to the function onFormSubmit and not the class SearchBar which is undefined



there are several ways of fixing this issue


one way of solving this is by binding the onFormSubmit function in the constructor

constructor(){
    this.onFormSubmit = this.onFormSubmit.bind(this)
}


another way of solving this is by using an arrow function which automatically binds the value of this for all the code inside the function i.e an arrow function doesn't have it's own this value

onFormSubmit = (event) => {
    ...
}














??????QUESTION?????? explain how you would pass the search term from the SearchBar component to the App component
??????QUESTION?????? pass the search term to the App component and console log it

















it's not really the work of the SearchBar component to fetch the results of the search. this would be the work of the App component instead


we'll need to figure out a way of communicating this search result from the child component SearchBar back to the parent App component


to do this we're going to convert our App component to a class component then define a onSearchSubmit callback function


whenever the App component shows the SearchBar, it is going to pass the onSearchSubmit function as a prop to the SearchBar component


when a user submits the form, it is going to call the callback function onSearchSubmit with the search term


this is very similar to the onChange and the onSubmit event handlers we have been using



refactor the App component to a class based component


create a function called onSearchSubmit on the class which gets called with the search term
~ onSearchSubmit(term){
        console.log(term)
  }


we'll then pass this as a prop on SearchBar
~ <SearchBar onSubmit={this.onSearchSubmit} />


the onSubmit prop for a component isn't similar to the onSubmit on an element an we could have as well given it any other name other than onSubmit
~ <SearchBar searchSubmitted={this.onSearchSubmit} />


we will then reference this callback in SearchBar onFormSubmit function which we'll be able to reference using the prop name passed i.e. props.searchSubmitted


something to note is that everytime we've used a prop so far it has been in a functional component

referencing a prop in a functional component
~ props.searchSubmitted

referencing a prop in a class component
~ this.props.searchSubmitted









??????QUESTION?????? install axios to your project and use it to fetch images of the search term and print below the search bar the number of images found from our search












/////       MAKING API REQUESTS WITH REACT      /////

we will be using unsplash api to get the images


go to unsplash developers and log in and create a new application


for full documentation of what we'll be using go to documentation > search photos


we will use axios to do our fetch requests

~ npm i axios

import axios from 'axios' //app.js


we will use the axios.get method which accepts two arguments, first the address where we want to make the get request to i.e. /search/photos and secondly an object which will help us customize this request


    async onSearchSubmit(term){
        const response = await axios.get('https://api.unsplash.com/search/photos', {
            params: { query: term },
            headers: {
                Authorization: 'Client-ID 1zf5l5lJZAHMIxHRseDydPkX-3Di_dAquqRweRCv-RQ'
            }
        });
    }



we will update the state with the result of the request in order to make our component rerender itself again

~ state = { images: [] }
initialize state at the top of the class

~ this.setState({images: response.data.results})
inside the onSearchSubmit function

~ Found: {this.state.images.length} images
for now we will print out the number of images found inside the render function

this will however cause an error as the this value isn't for the class but instead the onSearchSubmit function


correct this by converting the onSearchSubmit function into an arrow function

    onSearchSubmit = async (term) => {
        const response = await axios.get('https://api.unsplash.com/search/photos', {
            params: { query: term },
            headers: {
                Authorization: 'Client-ID 1zf5l5lJZAHMIxHRseDydPkX-3Di_dAquqRweRCv-RQ'
            }
        });

        this.setState({images: response.data.results})
    }


















we will now refactor our code to remove all the axios code in our App


create a folder called api in the src directory, create unsplash.js


we will put all the code related to configuration of unsplash to accept our axios request here


in unsplash.js, import axios


one good thing about axios is that we can set up a pre-configured instance of the axios client that has default properties set for where it is going to make the request to, headers, params etc


export default axios.create({
    baseURL: 'https://api.unsplash.com',
    headers: {
        Authorization: 'Client-ID 1zf5l5lJZAHMIxHRseDydPkX-3Di_dAquqRweRCv-RQ'
    }
})


we'll now import this instead of axios

import unsplash from '../api/unsplash'

then call this instead of axios

    const response = await unsplash.get('/search/photos', {
        params: { query: term },
    });










??????QUESTION?????? create a function component called ImageList which will receive the images from App component. render these images to make sure it worked well
??????QUESTION?????? make sure you have no errors or warnings in your console
??????QUESTION?????? use destructuring when mapping the images list for cleaner code













////        RENDERING THE IMAGES ON THE SCREEN   /////


create a functional component called ImageList with random text and import it to the App component and show it on the app


we will then pass the list of images from the App component to the ImageList component i.e. parent to child which we do using props
~ < ImageList images={this.state.images} />

we will then use a map to loop through all the images and print them

    const images = props.images.map(
        image => <img src={image.urls.regular} />
    )

    return (
        <div>
            {images}
        </div>
    )


this will now work, however it will throw a warning in the console that each child in a list should have a unique "key" prop


this is because when react is trying to render an item in a list, it will look for it in the dom. looking for it means it will check all the existing items in the dom if it exists so that it can update or not


having each item in a list containing a key means react will be able to look for the items more quickly and it improves the performance


we will then add the key/ id in the root tag of every item in our list i.e. the highest level element in our list


we happen to get ids from our results from unsplash at images.id

we'll also add description from the images to get rid of the alt warning

~ return <img alt={image.description} key={image.id} src={image.urls.regular} />


you can further simplify the code by destructuring from the map to reduce code repetition

const ImageList = (props) => {
    const images = props.images.map(({description, id, urls}) =>
    {
        return <img alt={description} key={id} src={urls.regular}/>
    }
)

























??????QUESTION?????? create ImageList.css in the components folder and import it in the ImageList component
??????QUESTION?????? give the root of the ImageList component a class name of image-list and add the following css
.image-list{
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
    grid-gap: 10px;
}

.image-list img {
    width: 250px;
}
??????QUESTION?????? what is a grid-auto-row and grid-row-end. explain how we can use this to reduce the white vertical space and why this using css only may not be enough to fix the white vertical space
??????QUESTION?????? create a new component called ImageCard and use it to print the image instead of the image tag in the ImageList component



















////        STYLING THE IMAGES      /////


we will use the grid css system

in the components' folder create a file called ImageList.css and import it in the ImageList component


add a class image-list to the root of our component

.image-list{
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
    grid-gap: 10px;
}

.image-list img {
    width: 250px;
}



grid-template-columns creates a set number of columns

auto-fill will decide how many columns to insert

minmax(250px, 1fr) means each column will be at minimum 250px wide and the maximum allocation of space wide


we're going to try and fix the vertical white spaces between the images

we can use grid-auto-rows to specify the height of an image and grid-row-end with span to specify how many grid spaces the image will occupy


however, this is difficult to do with css as all the images have varying heights


we will use react for this as we'll need to calculate the height of very image and based on this height determine the number of spans to be allocated


create a new react class component called ImageCard which will be responsible for rendering one image at a time


it will figure out the height of the image and based on this determine the grid-row-end span to accomodate for the size


class ImageCard extends React.Component{
    render() {
        const {description, urls} = this.props.image
        return (
            <div>
                <img alt={description} src={urls.regular} />
            </div>
        );
    }
}


also modify the images map now that we'll be passing our attributes and src to our component


note that we still have to pass the key however and we can not pass it to the component ImageCard

    const images = props.images.map((image) =>
        {
            return <ImageCard key={image.id} image={image}/>
        }
    )
















??????QUESTION?????? create a react ref for the image and console log the height of each image

















we will now use our ImageCard component to dynamically calculate the size of an image in the following steps
- we will let the ImageCard render itself and its image
- reach into the DOM and figure out the height of the image
- set the image height on state to get the component to rerender
- when rerendering, assign grid-row-end to make sure the image takes up the appropriate space



in vanilla js we can access the dom using document.querySelector etc


in react this is different and we use the ref system instead


it gives you access to a single dom element


we create refs in the constructor, assign them to instance variables, then pass to a particular JSX element as props


we don't necessarily have to store them in state cause their values won't change


in ImageCard class add the following code

constructor(props){
    super(props);

    this.imageRef = React.createRef();
}

then pass it as a ref in the render function image element

<img ref={this.imageRef} alt{description} src={urls.regular} />


now anywhere inside this component, we can reference this.imageRef and it will tell us about the img element


we will access this in the componentDidMount method where we will first wait for it to load and for now we'll just console log the heights


    componentDidMount() {
        this.imageRef.current.addEventListener('load', this.setSpans)
    }

    setSpans = () => {
        console.log(this.imageRef.current.clientHeight)
    }














??????QUESTION?????? with this height, use grid-auto-rows and grid-row-end to get rid of the vertical white space between the images












with this height, we can now calculate the number of spans that will be needed for each image


first add a grid-auto-row: 10px at image-list
this means each grid container will have a height of 10px


with smaller rows, this means the whitespaces will be smaller and more accurate


we'll then dynamically set the grid-row-end with a span of the number of grid containers it will need to cover its height comfortably

ImageCard.js

import React from 'react'

class ImageCard extends React.Component{
    constructor(props) {
        super(props);

        this.state = ({spans: 0})

        this.imageRef = React.createRef()
    }

    componentDidMount() {
        this.imageRef.current.addEventListener('load', this.setSpans)
    }

    setSpans = () => {
        const height = this.imageRef.current.clientHeight

        const spans = Math.ceil(height/ 10)

        this.setState({spans})
    }

    render() {
        const {description, urls} = this.props.image
        return (
            <div style={{gridRowEnd: `span ${this.state.spans}`}}>
                <img ref={this.imageRef} alt={description} src={urls.regular} />
            </div>
        );
    }
}

export default ImageCard



ImageList.css

.image-list{
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
    grid-gap: 0 10px;
}

.image-list img {
    width: 250px;
}









??????QUESTION?????? create a new react app called videos
??????QUESTION?????? do all the necessary set up and print Video App from the app component
??????QUESTION?????? wire up semantic ui and add a container to the App component using the following semantic ui class "ui container"
??????QUESTION?????? create the search bar and console log the search term from the App component using necessary styling from semantic ui shown  below
    <div className="search-bar ui segment">
            <form className="ui form">
                <div className="field">
                    <label>
                        Search Video
                    </label>
                    <div className="ui icon input">
                        <input type="text" />
                    </div>
                </div>
            </form>
    </div>












we're going to create a new app which is going to be a youtube mock up


this app is going to need several components
1. SearchBar
2. VideoDetail
3. VideoList
4. VideoItem




create a new react app called videos


do all the necessary set up and print Video App from the app component


we will first start with the SearchBar


create the search bar and console log the search term from the App component















??????QUESTION?????? create an api folder in src, create a youtube.js file and store this api key 'AIzaSyBAlbEkd8ZAhrmR3whfpo0TwEsSJ3Sc9a8' in a variable called KEY
??????QUESTION?????? install axios and set up a preconfigured instance of it in the youtube.js file an import it to the App component
??????QUESTION?????? fetch a list of videos based on the search term from the youtube api and console log them to make sure it works. console log only the relevant data
??????QUESTION?????? print below the search input Found: x videos with x being the number of videos returned from the search






















we're now going to wire the youtube api to our project


go to google developers console and create a project in order to get an api key

create an api folder in src and create a youtube.js file

store the api key in this file


install axios and set up a preconfigured instance of it in the youtube.js file

import axios from "axios";

const KEY = 'AIzaSyBAlbEkd8ZAhrmR3whfpo0TwEsSJ3Sc9a8';

export default axios.create({
    baseURL: 'https://www.googleapis.com/youtube/v3',
    params: {
        key: KEY,
        part: 'snippet',
        maxResults: 5
    }
})


import this axios request and call it youtube

use it to fetch the data from youtube and set them as state in our App component to enable it to rerender


we will default it to an empty array too


    state = { videos: [] }

    onTermSubmit = async (term) => {
        const response = await youtube.get('/search', {
            params: {
                q: term
            }
        })

        this.setState({videos: response.data.items})
    }


    inside the render function

    Found: {this.state.videos.length} videos











??????QUESTION?????? set up the VideoList and VideoItem components to print out the thumbnail and title of each video
??????QUESTION?????? give our VideoList root component a class name of 'ui relaxed divided list'
??????QUESTION?????? use the following structure for the VideoItem
<div className="video-item item">
    <img className="ui image" />
    <div className="content">
        <div className="header"> Title </div>
    </div>
</div>
??????QUESTION?????? inside the components' directory, create a VideoItem.css, add the css below and import it to VideoItem.js

.video-item {
    display: flex !important;
    align-items: center !important;
    cursor: pointer;
}

.video-item.item img {
    max-width: 180px
}

















we will now render the list of the videos on the right hand side of our page


we'll create two separate components, the VideoList and VideoItem


set up the VideoList and VideoItem components to print out the thumbnail and title of each video


give our VideoList root component a class name of 'ui relaxed divided list' and each VideoItem a root class name of item


check the questions above to complete the full styling












??????QUESTION?????? console log the video a user clicks from the App component














we will now look at how to open a detailed section of a video when a user clicks it


we'll add a new property on our state called selectedVideo and default it to null
state = { videos: [], selectedVideo: null }


when a user clicks on a video, we will update this to our state and pass it to a VideoDetail component


we will pass a callback function called onVideoSelect from the App to VideoList
    onVideoSelect = (video) => {
        console.log( 'From the App component', video)
    }

inside render function
    <VideoList onVideoSelect={this.onVideoSelect} videos={this.state.videos}/>



VideoList will then pass this callback to each VideoItem
    return <VideoItem onVideoSelect={onVideoSelect} key={video.id.videoId} video={video.snippet}/>


when a user clicks on a video, we will call the onVideoSelect function on the VideoItem and pass in the video clicked
    <div onClick={() => onVideoSelect(video) } className="video-item item">



this will invoke the onVideoSelect function which originates from the App and it will update its state












??????QUESTION?????? create a VideoDetail component which will print out on the screen the title of the video selected
??????QUESTION?????? use the following styles for the video title and description
    <div className="ui segment">
        <h4>Title</h4>
        <p>Description</p>
    </div>














we will now create the VideoDetail component and pass it the selected video


first we will update our state selectedVideo property with the selected video
    onVideoSelect = (video) => {
        this.setState({selectedVideo: video})
    }

now create a new component called VideoDetail which will show a video player and the video title and description underneath it


for now we will just print the video title
const VideoDetail = ({video}) => {
    if (!video){
        return <div>Loading...</div>
    }

    return <div>{video.title}</div>
}


we will then import this to the App component and call it between SearchBar and VideoList passing the selected video as a prop
    <VideoList onVideoSelect={this.onVideoSelect} videos={this.state.videos}/>


we will now display a styled video title with the description
    <div className="ui segment">
        <h4>{video.title}</h4>
        <p>{video.description}</p>
    </div>










??????QUESTION?????? display a video player for the video selected
??????QUESTION?????? use the following styles in App to display VideoDetail on the left and VideoList on the right
    <div className="ui container">
        <SearchBar />
        <div className="ui grid">
            <div className="ui row">
                <div className="eleven wide column">
                    <VideoDetail />
                </div>
                <div className="five wide column">
                    <VideoList />
                </div>
            </div>
        </div>
    </div>











we're now going to display the video player using an iframe which can attempt to make an outside request which will be youtube in this case which will reply with the necessary html, css and js to show the video player

    <div>
        <div className="ui embed">
            <iframe src={videoSrc} />
        </div>
        <div className="ui segment">
            <h4>{video.snippet.title}</h4>
            <p>{video.snippet.description}</p>
        </div>
    </div>


with videoSrc being
    const videoSrc = `https://www.youtube.com/embed/${video.id.videoId}`




we will then use semantic ui's grid system to make VideoDetail show on the left side and VideoList on the right

    <div className="ui container">
        <SearchBar termSubmit={this.onTermSubmit} />
        <div className="ui grid">
            <div className="ui row">
                <div className="eleven wide column">
                    <VideoDetail video={this.state.selectedVideo} />
                </div>
                <div className="five wide column">
                    <VideoList onVideoSelect={this.onVideoSelect} videos={this.state.videos}/>
                </div>
            </div>
        </div>
    </div>














the app is now looking good with only one thing left. when a user first visits our app it shows the loading text as no input has been received from the user


we will use a default search term


one other issue is that when a user searches again, it still shows video details of the previously selected video


when a user searches for a video, we will pic one of the videos to be the selected video
    this.setState({
        videos: response.data.items,
        selectedVideo: response.data.items[0]
    })



for the default search term, we will define a componentDidMount life cycle method an manually call onTermSubmit function



















??????QUESTION?????? initialize a new react app called widgets and print Widgets App on the screen
??????QUESTION?????? in App, create an items array and hard code an array of objects which contain a title and content property
??????QUESTION?????? create an Accordion component which will receive this items element and print out the number of items in the array


















/////       THE HOOKS SYSTEM            ///


the hooks system is basically a way of giving functional components more functionality e.g

useState - a function that lets you use state in a functional component

useEffect - a function that lets you use something like lifecycle methods in a functional component

useRef - a function that lets you create a ref in a functional component


hooks are also a way to write reusable code instead of more classic techniques like inheritance


hooks give you a set of functions e.g. useState and on top of that you can create your custom hooks which will be doing one repeatable task


you can also use the set of predefined functions in your custom hook


we will be building a Widget application that will include multiple components. These components will be:
- An Accordion component
- A Wikipedia API search component
- A Dropdown item selection component
- A Google Translate API component

We will then wrap up the Widgets application by building our own navigation using JS and React without a third-party library like React Router. This will be used to navigate between the different widget components that were built.


initialize a new react app called widgets
~ create-react-app widgets


we will create an Accordion component and show it in the App component


create an array of items which we will pass down to it as props


we will hard code this items array in our App and every element in that array will be an object with a title and content properties


we will then communicate this to Accordion as props


you can create this array anywhere in the App, it looks better when done after the import statements

const items = [
    {
        title: 'Question 1',
        content: 'Answer 1'
    },
    {
        title: 'Question 2',
        content: 'Answer 2'
    },
    {
        title: 'Question 3',
        content: 'Answer 3'
    }
]


for now we'll just print the number of items in the list











??????QUESTION?????? wire up semantic ui to the project
??????QUESTION?????? give the root of Accordion the following style
<div className="ui styled accordion">
??????QUESTION?????? render the list of items using map and the following styles
     <React.Fragment key>
         <div className="title active">
             <i className="dropdown icon" />
             Title
         </div>
         <div className="content active">
             <p>Content</p>
         </div>
     </React.Fragment>
??????QUESTION?????? what is a React.Fragment and why do we use it in this case
??????QUESTION?????? create a function called onTitleClick which prints the index of the element clicked
??????QUESTION?????? call this function when a user clicks the title of the accordion











React.Fragment is kind of a react tag that we use when we don't want to use an extra html tag


in this case we don't want to use a div cause semantic ui will kind of treat that as another accordion and it will have a double border at the top. in order to avoid that instead of using a div wrapper will, we will use React.Fragment


the styling looks good and the next thing we need to do is how to detect when a user clicks one of the titles


when a title is clicked, we will console log title clicked with the index


note that a map function allows us to pass the index of the element as a second argument and we will log this

  const renderedItems = items.map(
      (item, index) => {
         return(
             <React.Fragment key={item.title}>
                 <div className="title active" onClick={() => onTitleClick(index)}>
                     <i className="dropdown icon" />
                     {item.title}
                 </div>

....

    const onTitleClick = (index) => {
        console.log(`Title ${index} was clicked`)
    }















??????QUESTION?????? using hooks, print out the index of the element clicked after the accordion



















we're now going to make use of the hooks system in react


to learn this we will attempt to print out the index of the element clicked below the accordion


for a class based component we would simply
1. initialize a state with a property activeIndex
2. we will setState with the index when a user clicks a title
3. below the accordion we will print the value of the activeIndex from the state


for hooks its a little bit different


first we will import the useState function from react
import React, {useState} from 'react'


this is how we would initialize the state
const [activeIndex, setActiveIndex] = useState(null)

whenever we call useState, we get an array with two elements. the first element is our state item which will change over time while the second element is a function that we can use to update the value of the first element and just like setState it will cause our component to automatically rerender

whenever we call useState, it takes in one argument which is going to be the default value of our piece of state


this is how we would setState
setActiveIndex(index)


and this is how we would print the index of the element clicked below the accordion
<h1>{activeIndex}</h1>











??????QUESTION?????? set up the collapsing and expanding of the clicked accordion and also remove the print out for the active index









we will now look at expanding and collapsing the accordions


the expanding happens because of the active class in the title and content


in order to make it dynamic, while rendering our items, we will compare the index with the activeIndex, if they are the same we will give it a class of active and if they aren't the same it wont have the class active which will make it collapse


const active = index === activeIndex ? 'active' : ''


we will then join this with the class name for title and content

className={`title ${active}`}

className={`content ${active}`}


we can now also remove the print out of the activeIndex










??????QUESTION?????? delete the jsx for the Accordion. we will now be creating a search widget
??????QUESTION?????? create a search a function component called Search with the styling below and wire it to anticipate changes using state
      <div>
          <div className="ui form">
              <div className="field">
                  <label htmlFor="search">Enter Search Term</label>
                  <input type="text" className="input"/>
              </div>
          </div>
      </div>











we just finished building one widget and we'll move on to the next


we're going to create a search widget which is going to make use of the useState and useEffect hooks


its going to have a search input where a user can type in some topic. we will take this term and search the wikipedia api and return the results


we will be printing out the title and the snippet of the search term


we will also keep it simple unlike the youtube clone and have only two components, the App component and the Search component


the Search component will have two pieces of state, the term and results


delete the jsx for Accordion in App


create a new Search component and give it the classes below

      <div>
          <div className="ui form">
              <div className="field">
                  <label htmlFor="search">Enter Search Term</label>
                  <input type="text" className="input"/>
              </div>
          </div>
      </div>



the logic for the Search component is going to be the same as the youtube one before with the only difference being we're using a functional component now


we will initialize term in our state using useState

const [term, setTerm] = useState('')

then wire our input with state

    <input type="text" className="input" value={term}
           onChange={(event) => setTerm(event.target.value)}
   />












??????QUESTION?????? what is useEffect and how is it used














we will now take the search term to the wikipedia api


when a user updates the term, our component will rerender. we will then add code to detect that term has changed using the useEffect hook


the useEffect hook allows function components to use something like lifecycle methods


we configure the hook to run some code automatically in one of three scenarios
1. when the component is rendered for the first time only
2. when the component is rendered for the first time and whenever it rerenders
3. when the component is rendered for the first time and whenever it rerenders and some piece of data has changed


we will first import useEffect the same way we import useState


to make use of useEffect, we will call it and provide a function as the first argument


we will then configure it and tell it when we want it to be executed based on the 3 scenarios above


this is provided as the second argument in useEffect. this is going to be
1. an empty array, at initial render (scenario 1)
2. no array at all, at initial render and after every rerender (scenario 2)
3. an array with some value inside of it, run at initial render, run after every rerender if some element inside the array we passed has changed since last render (scenario 3). this array can have more than one element and useEffect is going to run if either of those elements change













??????QUESTION?????? make a search request to wikipedia api using the search term the user inputs. console log this response
use the link below to configure your request
https://en.wikipedia.org/w/api.php?action=query&list=search&origin=*&format=json&srsearch=cats




















we're now going to use scenario 3 and when the value of term changes, will make a request to wikipedia api


to make the request we will need to install axios


unfortunately we can't use the normal async await syntax with useEffect


there are three alternatives that we can use


1. inside use effect, create another async await helper function an call it in useEffect

const search = async () => {
    await axios.get('')
}

search()

this method is what is recommended

2. similar to the function but instead of creating a variable for the function, we create a self invoking function

(async () => {
    await axios.get('')
})();

3. use normal promises with .then

axios.get('').then( (response) => {
    console.log(response)
})


    useEffect(() => {
        const search = async () => {
          const response = await axios.get('https://en.wikipedia.org/w/api.php', {
              params: {
                  action: 'query',
                  list: 'search',
                  origin: '*',
                  format: 'json',
                  srsearch: term
              }
          })

          console.log(response)
        }

        search()
    }, [term])














??????QUESTION?????? save the array of results from the response to a new piece of state called results and console log its value
??????QUESTION?????? what are the two ways we can use to overcome the error in our results array due to the fact that our search term is an empty string by default
















we will create a new piece of state called results with it set method setResults with the default value as an empty array

const [results, setResults] = useState([])


we will then setResults to the data.query.search we receive from our request

setResults(response.data.query.search)


if we try and console log the value of results, we will get an error because our initial value of term is an empty string and the wikipedia api doesn't allow a search for an empty string


one solution for this is to set a default word as the value for term


another alternative is before running the search function, we will check if term has a value or not

        if (term) {
            search()
        }

an empty string is a falsy therefore the search function will not run

















??????QUESTION?????? use the classes below to style your list and find a workaround to remove the html tags in the code
    <div className="item">
        <div className="right floated content">
            <a
                className="ui button"
                href={`https://en.wikipedia.org?curid=${get the page id}`}>
                Go
            </a>
        </div>
        <div className="content">
            <div className="header">
                Title
            </div>
            Summary
        </div>
    </div>






















map through the results using the following styles

        <div key={result.pageid} className="item">
            <div className="right floated content">
                <a
                    className="ui button"
                    href={`https://en.wikipedia.org?curid=${result.pageid}`}>
                    Go
                </a>
            </div>
            <div className="content">
                <div className="header">
                    {result.title}
                </div>
                {result.snippet}
            </div>
        </div>



after the closing div of the ui form, add the following styles

        <div className="ui celled list">
            {renderedResults}
        </div>


this works but some html tags are displayed as text

    <span dangerouslySetInnerHTML={{__html: result.snippet}}/>














??????QUESTION?????? throttle the search so that the search only happens after 1 second
(HINT use useEffect)
??????QUESTION?????? set a default search term as react. note that the throttle applies for this default search too. fix this bug



















we will now throttle our api requests to avoid a search on every input change


on input change, we will set a timer to search in 500ms, if another input change happens before this we will set another timer to search in 500ms

if 500ms expires without any input change we will execute the last timer


we can useState to monitor the timeout and cancel it if need be


however there is a much better way by using useEffect


the only thing we're allowed to return from a useEffect function is another function


the goal of that return function is to do some clean up


when the app first renders, the return function isn't automatically called

when the useEffect is run again, react will automatically return the return function from the previous run first then it will call the general function


    const timeoutId = setTimeout(() => {
        if (term) {
            search()
        }
    }, 1000)

    return() => {
        clearTimeout(timeoutId)
    }

 

unfortunately, this throttle still works for the default search if we hard coded our default search term. we will need to do an immediate search for the first run if we have a default word

    if (term && !results.length){
        search()
    } else {
        const timeoutId = setTimeout(() => {
            if (term) {
                search()
            }
        }, 1000)

        return() => {
            clearTimeout(timeoutId)
        }
    }














??????QUESTION?????? create a new component called Dropdown which prints dropdown, export it and import in App, delete the jsx for Search and use Dropdown instead
??????QUESTION?????? create an array of options which are objects containing label and value. pass it to Dropdown as prop
??????QUESTION?????? map through the options array in Dropdown and use the following style
  const renderedOptions = options.map(
      option => {
        return(
            <div key={option.value} className="item">
              {option.label}
            </div>
        )
      }
  )

??????QUESTION?????? style the jsx for the Dropdown as below
  <div className="ui form">
    <div className="field">
      <label htmlFor="dropdown" className="label" >
        Select a color
      </label>
      <div className="ui selection dropdown visible active">
        <i className="dropdown icon"/>
        <div className="text">Select color</div>
        <div className="menu visible transition">
          {renderedOptions}
        </div>
      </div>
    </div>
  </div>























we're now going to move to our next widget, the dropdown widget which is going to make use of the useState, useEffect and useRef hooks


when the user clicks on the dropdown with some color selections. when a user selects a color it will update some text color immediately after it


we will have two components, App and Dropdown. Dropdown will receive props options of the dropdown menu from App


the options itself is going to be an array of objects with label and value
{
    label: 'Red or any random text',
    value: 'red'
}


we will also have a piece of state called selection which is going to record what the current selection is


this piece of state is going to exist in App and we will pass it as a prop to Dropdown


create a new component called Dropdown which prints dropdown, export it and import in App, delete the jsx for Search and use Dropdown instead


in App, create the options array and pass it to Dropdown as a prop

const options = [
    {
        label: 'Red',
        value: 'red'
    },
    {
        label: 'Green',
        value: 'green'
    },
    {
        label: 'Blue',
        value: 'blue'
    }
]



















??????QUESTION?????? create a selected piece of state in the appropriate component with the default value of the first item in our options array
??????QUESTION?????? in Dropdown component, replace the div which shows the selected item on the dropdown with the value in the selected state
??????QUESTION?????? when a user clicks on the items in the dropdown, replace it the selected element
??????QUESTION?????? do not show the selected item on the dropdown menu
??????QUESTION?????? add the opening and closing functionality in our dropdown. by default it should be closed, when a user clicks on it it should open and when a user selects something it should close





















we will now work on our selection piece of state to keep track of what option is selected, we will also pass the selection setter as a prop


  const [selected, setSelected] = useState(options[0])


  <Dropdown
      selected={selected}
      onSelectedChange={setSelected}
      options={options}
  />


we will then wire these up in our Dropdown component


replace the div with select color text in our dropdown using the selected label

<div className="text">{selected.label}</div>


add an onClick function to our map which calls the setSelected function an causes a rerender
    <div
        key={option.value}
        className="item"
        onClick={() => onSelectedChange(option) }
    >
      {option.label}
    </div>


to improve the dropdown, we will not show the selected item on the dropdown menu

in the options map we will add this if statement before the return statement

    if (option.value === selected.value){
      return null
    }

null in react means don't render anything




the next thing is to add the opening and closing functionality in our dropdown


by default it should be closed, when a user clicks on it it should open and when a user selects something it should close

const [open, setOpen] = useState(false)

    <div className="ui form">
        <div className="field">
          <label htmlFor="dropdown" className="label" >
            Select a color
          </label>
          <div onClick={() => setOpen(!open) } className={`ui selection dropdown ${open ? 'visible active': ''}`}>
            <i className="dropdown icon"/>
            <div className="text">{selected.label}</div>
            <div className={`menu ${open ? 'visible transition' : ''}`}>
              {renderedOptions}
            </div>
          </div>
        </div>
  </div>















??????QUESTION?????? explain why the dropdown closes when we click on an item in our menu despite us not having code that say the dropdown should close when we click on an item in our menu
??????QUESTION?????? make the dropdown close when we click outside the dropdown while maintaining the current opening and closing functionality still
??????BONUS QUESTION?????? add some text below the dropdown e.g this is red, the text should be written in the color of the item selected in the dropdown i.e this is red should be in red














we now want to close the dropdown when a user clicks outside the dropdown


the Dropdown can only easily listen an handle events from the elements it contains. in this case we're trying to listen for a click outside the Dropdown component


to do this we need to understand event bubbling in the dom


when a user clicks on something, the event objects contains the details on the click. the browser will then hand this event object to react which does some processing and provides the object to our onClick handler


the event object doesn't stop here, it goes to the parent element and checks if it has an onClick function. if it does it invokes it if it doesn't it goes to the parent of that element


this is what is called event bubbling


this is why when we click on an element in our menu, it bubbles up to the onClick function in its parent an closes up the dropdown menu


based on this, we will try to fix this problem this way. the Dropdown can set up a manual event listener (without react) on the body element. a click on any any element will bubble up to the body


we will use a useEffect hook in our Dropdown and whenever our component is rendered for the first time on the screen we can set up an event listener on the body element

  useEffect(() => {
    document.body.addEventListener("click",
        () => {
          setOpen(false);
        },
        { capture: true }
    );
  }, []);


the dropdown now closes when we click outside it but when we click on an item, it doesn't


this is because of the order of event bubbling and the order which onClick functions are called


body is called first, then item then dropdown


this is because the manual event listeners like the body are called first then the react event listeners


when we click on an item, body closes the dropdown but the onClick on dropdown reverses this, opens the dropdown again


to fix this, when a user clicks on a Dropdown element, we don't want the body listener to do anything.


when a user clicks on any element other than the Dropdown elements, we want the body listener to close the dropdown


we can figure out which element was clicked by checking event.target which gives us the dom element


in order to figure out if the element is a dropdown element, we will use useRef hook which will allow us to get a direct reference to a dom element. using this we will find the most parent element of the dropdown which is the ui form


import useRef

const ref = useRef();


we will then assign it to one of the elements that we are returning from the Dropdown component and in our case the most parent element which is the div ui form

<div ref={ref} className="ui form">


we can get a reference to that div by using ref.current


    useEffect(() => {
        document.body.addEventListener("click",
            (event) => {

                if (ref.current.contains(event.target)) {
                    return
                }
                setOpen(false);
            },
            {capture: true}
        );
    }, []);




















??????QUESTION?????? create a new component called Translate and import the Dropdown component
??????QUESTION?????? use the hard coded array of options
const options = [
    {
        label:'Afrikaans',
        value:'af'
    },
    {
        label:'Arabic',
        value:'ar'
    },
    {
        label:'Hindi',
        value:'hi'
    }
]
??????QUESTION?????? initialize state (language) and select the first option as the default option
??????QUESTION?????? pass in the necessary props required for Dropdown
??????QUESTION?????? import this in App, delete the jsx for Dropdown and show translate instead
??????QUESTION?????? using the styles below, create a controlled input which will store the text that a user inputs
    <div className="ui form">
        <div className="field">
            <label htmlFor="input">Enter Text</label>
            <input type="text" value={text} onChange={event => setText(event.target.value)} />
        </div>
    </div>
























our last widget will be a translate widget where when a user inputs a text, they can select a language they want the text translated to which is displayed below


we will reuse our dropdown component here


our App will have 4 components, the App for general control, Translate which will be responsible for displaying the page, controlling the state and passing props and the Dropdown and Convert components


create a new component called Translate and import the Dropdown component


create a hard coded array of options

const options = [
    {
        label:'Afrikaans',
        value:'af'
    },
    {
        label:'Arabic',
        value:'ar'
    },
    {
        label:'Hindi',
        value:'hi'
    }
]


initialize state and select the first option as the default option

const [language, setLanguage] = useState(options[0])


the Translate component returns the Dropdown where we pass options as props. the Dropdown component also expects a selected and onSelected prop

    <div>
        <Dropdown
            selected={language}
            onSelectedChange={setLanguage}
            options={options}
        />
    </div>


import this in App, delete the jsx for Dropdown and show translate instead



we'll pass in a prop to customize the label that is shown on Dropdown instead of select a color

    label="Select a language"

    <label htmlFor="dropdown" className="label">
        {label}
    </label>



we'll create an input text which will track what the user inputs using a piece of state (text)

const [text, setText] = useState('')

    <div className="ui form">
        <div className="field">
            <label htmlFor="input">Enter Text</label>
            <input type="text" value={text} onChange={event => setText(event.target.value)} />
        </div>
    </div>



































??????QUESTION?????? create a Convert component which will accept two props language and text which will be taken to the google translate api
??????QUESTION?????? set up google translate api using the axios request below to get the translated text stored at
response.data.data.translations[0].translatedText

const response = await axios.post('https://translation.googleapis.com/language/translate/v2', {}, {
                params: {
                    q: text,
                    target: language.value,
                    key: 'AIzaSyCHUCmpR7cT_yDFHC98CZJy2LTms-IwDlM'
                }
            })

??????QUESTION?????? Convert should return the styles below
       <div>
            <h1 className="ui header">
                translated text
            </h1>
       </div>

??????QUESTION?????? import Convert in Translate add the following styles
    <hr/>
    <h3 className="ui header">Output</h3>
    <Convert text={text} language={language} />





















ANSWER

import React, {useState, useEffect} from "react";
import axios from "axios";

const Convert = ({language, text}) => {

    const [translated, setTranslated] = useState('')

    useEffect(() => {
        const doTranslation = async () => {
            const response = await axios.post('https://translation.googleapis.com/language/translate/v2', {}, {
                params: {
                    q: text,
                    target: language.value,
                    key: 'AIzaSyCHUCmpR7cT_yDFHC98CZJy2LTms-IwDlM'
                }
            })

            setTranslated(response.data.data.translations[0].translatedText);
        }

        doTranslation()

    }, [language, text])


    return(
       <div>
            <h1 className="ui header">
                {translated}
            </h1>
       </div>
    )
}

export default Convert













??????QUESTION?????? debounce the axios request when a user changes the input to 500ms

















we now need to debounce/ throttle the axios request to 500ms


we will create two separate useEffect functions
1. - set a time to update debouncedText in 500ms
   - return a clean up function that cancels this timer

2. make a request with debouncedText


    const [translated, setTranslated] = useState('')
    const [debouncedText, setDebouncedText] = useState(text)

    useEffect(() => {
        const timerId = setTimeout( () => {
                setDebouncedText(text)
            }, 500)

        return () => {
            clearTimeout(timerId)
        }

    }, [text])

    useEffect(() => {

        const doTranslation = async () => {
            const response = await axios.post('https://translation.googleapis.com/language/translate/v2', {}, {
                params: {
                    q: debouncedText,
                    target: language.value,
                    key: 'AIzaSyCHUCmpR7cT_yDFHC98CZJy2LTms-IwDlM'
                }
            })

            setTranslated(response.data.data.translations[0].translatedText);
        }

        doTranslation()

    }, [language, debouncedText])













































