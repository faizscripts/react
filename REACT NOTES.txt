the app function is called a react component
it produces jsx and handles user events
it returns jsx which is html content which shows on the screen
jsx can show a normal html element or show react components





??????QUESTION?????? explain how react works and write a line which starts the project
??????QUESTION?????? what are the two react libraries necessary to run a react project and what is their roles
??????QUESTION?????? what is useState



the browser makes a request to the server and it gets back an index.html file which is stored in the public folder, the index file contains scripts which tells the browser to get all the js files i.e app.js, index.js and the react components which are bundled together into a bundle.js file

this js is then converted to html and placed in the index.html file

the first js file that gets executed is index.js which sets up the project.

 it calls the app function <App/> and index.html which contains an ID tag root document.getElementById("root") in this case

ReactDOM.render(<App/>, document.getElementById("root"))

whenever were working with react, we work with two separate libraries i.e React and ReactDOM

React works with components and it's called a reconciler

ReactDOM turns instructions into html and it's called a renderer

useState is a function for working with react's state system. state is used to keep track of data that changes over time. it makes react update the html on the screen




??????QUESTION?????? what are the two possible ways to create a react project
??????QUESTION?????? create a react project called jsx and explain the project structure
??????QUESTION?????? start the react project
??????QUESTION?????? delete all the files in the src folder and make the app display Hello React






we're now going to install a tool called create-react-app which is going to help us set up a new project
~ npm i -g create-react-app

to create a project you now run create-react-app with the name of the project
~ create-react-app projectName


~ npx create-react-app projectName
installs create-react-app and creates a new project in one command


we use create-react-app because it installs for us a ton of dependencies that we don't have to install manually and are important for the running of a react application e.g babel, webpack, dev server


the create-react-app gives us a project structure which consists of the following files

src folder - where we put all the source code we write
public folder - stores static files e.g images
node_modules
package.json
readme


~ npm start
start create-react-app


delete everything in the src folder and create an index.js file


we will use three guidelines in our index.js file
1. import React and ReactDOM libraries
import React from 'react';
import ReactDOM from 'react-dom';

2. create a react component
a react component is a function or a class that produces HTML using JSX and handles feedback from the user using event handlers
const App = () => {
  return <div>Hello React</div>
}

3. show the react component on the screen
ReactDOM.render(<App/>, document.querySelector('#root'))
















??????QUESTION?????? what happens when you start the jsx of the app function on a new line, what is the way around for this for a multiline jsx block
??????QUESTION?????? convert the following piece of code to jsx. also instead of the submit text, create a variable string called click me and pass in the value instead
<div>
    <label for="name" class="label"> Enter name: </label>
    <input id="name" type="text"/>
    <button style="background-color:blue; color:white"> Submit </button>
</div>
??????QUESTION?????? what type of variable doesn't work in jsx


















/// BUILDING CONTENT WITH JSX

jsx gets converted into normal looking js code by babel

jsx is similar to html but it differs in the following ways
1. adding custom styling uses a different syntax
    <div style="background-color:blue;"> </div>
    <div style={{backgroundColor: 'blue'}}> </div>

2. adding a class to an uses a different syntax, for attribute also uses htmlFor
    <label htmlFor="name" className="label"> Enter name: </label>

3. jsx can reference js variables
    {variableName}

///ANSWER
import React from 'react';
import ReactDOM from 'react-dom';

const App = () => {
    const buttonText = 'Click Me!'

  return (
      <div>
        <label htmlFor="name" className="label"> Enter name: </label>
        <input id="name" type="text"/>
        <button style= {{ backgroundColor:'blue', color:'white' }}> {buttonText}</button>
      </div>
  )
}

ReactDOM.render(<App/>, document.querySelector('#root'))



calling an object in the place of text will not work, you will need to reference the keys of the object instead
const buttonText = {text: 'Click me'}

{buttonText} will not work but {buttonText.text} will













??????QUESTION?????? create a react app called components, delete all the files in the src folder and make it print out hello world
??????QUESTION?????? load semantic ui to your project
??????QUESTION?????? add the following jsx in your app function
    <div className="ui container comments">
      <div className="comment">
        <a href="/" className="avatar">
          <img alt="avatar" />
        </a>
        <div className="content">
          <a href="/" className="author">
            Sam
          </a>
          <div className="metadata">
            <span className="date">Today at 6:00PM</span>
          </div>
          <div className="text">Nice blog post!</div>
        </div>
      </div>
    </div>
??????QUESTION?????? use faker to generate random fake images for the avatar of the comment











//// COMMUNICATING WITH PROPS   ////

in this section we're going to focus on 3 things
1. component nesting
2. component reusability
3. component configuration - configure a component when it is created


we're going to create a web app which displays a list of comments


create a new react app called components and delete all the src files

create and index.js file in src and import the necessary libraries and print out Hello world


we're going to use semantic ui for our styling.

google its cdn for the min.css and add it to index.html
an indication that the semantic ui has loaded is that you'll notice that the fonts in your page have changed

add the following jsx in your app function which utilizes semantic ui

    <div className="ui container comments">
      <div className="comment">
        <a href="/" className="avatar">
          <img alt="avatar" />
        </a>
        <div className="content">
          <a href="/" className="author">
            Sam
          </a>
          <div className="metadata">
            <span className="date">Today at 6:00PM</span>
          </div>
          <div className="text">Nice blog post!</div>
        </div>
      </div>
    </div>


we're going to avoid the hustle of downloading and referencing images to save time so instead we'll use a js library called faker.js which generates a massive amount of realistic fake data

~ npm install @faker-js/faker --save-dev

import { faker } from '@faker-js/faker';

<img alt="avatar" src={faker.image.avatar()} />









??????QUESTION?????? execute the most viable way of creating multiple comments and create 3 comments with dynamic authors, time ago, text and image avatar
??????QUESTION?????? create an approval card component which creates a card with an option to approve or reject the comment. style the card using semantic ui cards
??????QUESTION?????? to test reusability of the ApprovalCard, pass some text 'Are you sure' instead of the comment











one way of adding more comments is duplicating the comment code. as you can imagine, this will make the code untidy and difficult to manage


we're going to refactor this code to create reusable components


the series of steps to follow when creating reusable components are
- identify the duplicated jsx
- what is the purpose of the block of jsx? give it a descriptive name
- create a new file to house this component which will have the same name
- create a new component in the file and paste the jsx
- make the new component configurable by using react's props system




in the src folder create a new file called CommentDetail.js. usually react components are written in uppercase


import react and faker then create a function called CommentDetail which you'll paste the comment jsx

in order to use this file inside index.js we will have to export it and import it in index.js


export default CommentDetail;

import CommentDetail from './CommentDetail'

we will then make this component configurable by using reacts prop system


the prop system passes data from a parent component to a child component. the goal is to customize or configure a child component

<CommentDetail author="Sam" />

in the component detail function, the default argument props is an object which contains all the data passed from the parent in key and value pairs. in this case the props object will contain a key of author and the respective value passed by the parent.


this can be destructured at the argument level ({author}) the the variable author called where we were hardcoding the author value

      <a href="/" className="author">
          {author}
      </a>



we're now going to look at props reusability. we're going to create an approval card for the comments where the admin can approve or reject the comments


we'll create another component called approval card which will contain an outline around the comment with two buttons. we will use this together with the CommentDetail component


create ApprovalCard.js inside src folder and add the necessary boilerplate code with card styling from semantic ui

const ApprovalCard = (props) => {
  return (
          <div className="ui card">
              <div className="content">
                  {props.children}
              </div>
              <div className="extra content">
                  <div className="ui two buttons">
                      <div className="ui basic green button">Approve</div>
                      <div className="ui basic red button">Decline</div>
                  </div>
              </div>
          </div>
  )
}


the ApprovalCard component in index.js will have opening and closing tags which will enable us to access the CommentDetail as a child when passed in between the tags


        <ApprovalCard>
            <CommentDetail author={faker.name.findName()} timeAgo="Today at 4.45PM" text="Awesome stuff" avatar={faker.image.avatar()}/>
        </ApprovalCard>


the approval card is reusable and it can even be passed some plain text or html instead of the comment

        <ApprovalCard>Are you sure?</ApprovalCard>

        <ApprovalCard>
            <div>
                <h4>Are you sure in HTML</h4>
            </div>
        </ApprovalCard>













??????QUESTION?????? what are the two different types of components and what is the difference between them
??????QUESTION?????? create a new react project called seasons, link up semantic ui to the project
??????QUESTION?????? for starting, we will use two function based components. create an App component which prints out Hello World and a SeasonDisplay component which prints out Seasons






//////  STRUCTURING APPS WITH CLASS BASED COMPONENTS    ///














there are two types of components, function and class components


functional components
1. can produce jsx to show content to the user
2. can use hooks to run code at specific points in time
3. can use hooks to access state system and update content on screen
4. good for simple content


class components
1. can produce jsx to show content to the user
2. can use lifecycle method system to run code at specific points in time
3. can use the state system to update content on the screen
4. good for just about everything else


if both components have almost the same capabilities, it begs the question, which one should we use


old projects most likey run with class based components as function based components had restricted use in the past


newer projects may be using class based or function based components


we're going to create a simple react app to understand this. the app is going to check the users location and month then print the season the user is currently experiencing


create a new project called seasons and link it up with semantic ui


delete files in src and create index.js


for starting we will have two components, an app component which has code to determine location + month and a seasons display component which shows different text/ icons based on props


in the index.js write the necessary boilerplate code and print Hello World


also create another file called SeasonDisplay.js which prints out season








??????QUESTION?????? use window.navigator.geolocation.getCurrentPosition() to get the users location. it accepts two callback functions, use them to console log the result and the error
??????QUESTION?????? what is the issue of using a function based component with this call back function











we're now going to look at how to get the users physical location using functions that are build into most morder browsers


this is Geolocation API


    window.navigator.geolocation.getCurrentPosition(
        position => console.log(position),
        positionError => console.log(positionError)
    )
gets the location, however it takes time so you'll have to use a callback function


add this to your App function


the getting location function takes some time to execute. however our function will continue execution and return jsx which will make it impossible to get back to our callback function














??????QUESTION?????? what are the 3 rules of a class based component
??????QUESTION?????? initialize the state system which will have a property lat
??????QUESTION?????? why do we use the super function
??????QUESTION?????? how can you access the values in your state













one way around this is using class based components and react state system where once after getting the result of the geolocation we will tell the app to rerender itself with this new information


a class based component follows the following rules
1. must be a js class
2, must extend React.Component class
3. must define a render method that returns some amount of jsx


class App extends React.Component{
    render(){
        return <div>This is a class based component</div>
    }
}


we extend from react component because react expects several other methods attached to it in order to work. however we don't have to create all of these therefore we borrow them from the React.Component class


in order to access the data from the callback which takes time to execute, we will use the state system


rules of the state system
1. only usable with class components (*might technically be used with functional components but this will be further discussed later)
2. don't confuse props with state
3. state is a js object that contains data relevant to a component
4. state must be initialized when a component is created
5. updating state on a component causes the component to (almost) instantly rerender
6. state can only be updated using the function setState




in order to initialize state when our component is created, we will use a constructor function which normally is the first function called in a class


there are other ways of initializing a state but for now we will just start with this constructor way


the constructor method will be automatically called with the props object


~ super(props)
we will then call a function called super which is borrowed from the parent class React.Component and pass the props. this will make sure that the constructor method in the parent class is called


~ this.state = { lat: null }
this will initialize the state and since we know before hand that we will be using the latitude value from our callback function, we will create a property lat and set its value to null



    constructor(props) {
        super(props);

        this.state = { lat: null}
    }


~ {this.state.null}
after initializing the state, we can access it from anywhere inside our class based component












??????QUESTION?????? refactor the getting latitude function so that it doesn't get called everytime our component is rendered. why is this refactor important
??????QUESTION?????? update the value of state to the latitude result of the callback and print it out on the screen
??????QUESTION?????? create another property of our state called errorMessage. in the case an error occurs update the value of errorMessage to store the error from the callback
??????QUESTION?????? edit the render function to print the latitude value if its present, the error message if an error occurred or loading is the results haven't been fetched yet




















if we update our state after we get the results from our callback function, this will make the component to rerender and we will be able to access the latitude value



note that the rerendering will cause the getCurrentPosition function to be called all the time. due to this we will move it to our constructor so that it is called when the component is created for the first time and avoid the repetition



~ this.setState({lat: position.coords.latitude})
we will also update our state to get the value of latitude from our callback function. the console log isn't necessary at this point



create another property of our state called errorMessage. in the case an error occurs update the value of errorMessage to store the error from the callback

~ this.state = { lat: null, errorMessage: ''}

~   positionError => {
         this.setState({errorMessage: positionError.message})
    }


edit the render function, add a new line which prints out the value of the error message

~    render() {
         return (
             <div>
                 Latitude: {this.state.lat}
                 <br/>
                 Error: {this.state.errorMessage}
             </div>
         )
     }



the code now works well, however printing out the word error all the time doesn't look good


we will look at the scenarios that can occur with our latitude situation
1. have latitude, no errorMessage   - show latitude
1. no latitude, have errorMessage   - show errorMessage
1. no latitude, no errorMessage     - show loading...



we can implement this using an if statement in our render function

   render() {
        if (this.state.errorMessage && !this.state.lat){
            return <div>Error: {this.state.errorMessage}</div>
        } else if (!this.state.errorMessage && this.state.lat){
            return <div>Latitude: {this.state.lat}</div>
        } else return <div>Loading...</div>
   }














??????QUESTION?????? describe the component lifecycle with all the methods associated to it. explain what the methods are used for
??????QUESTION?????? do all the data loading in the componentDidMount method
??????QUESTION?????? use the alternative way of initializing the state












we're going to refactor our code and initialize our state using an alternative way


in order to do this we need to understand life cycle methods


-the component starts with a constructor then the render method is called. the content now becomes visible on the screen. in the render method, avoid doing anything besides returning jsx
- a componentDidMount function is then automatically called, this is called once when our component is rendered on the screen for the first time. this is a good place to do data loading
- our component will now sit and wait for updates
- when an update happens on our state, the component is rerendered and a componentDidUpdate function is called automatically. this is a good place to do more data loading when state/ props change
- this update cycle is then repeated until the component is no longer shown where a componentWillUnmount function will be automatically called. this is a good place to do clean up especially for non react stuff


there are 3 other lifecycle methods but they're rarely used
1. shouldComponentUpdate
2. getDerivedStateFromProps
3. getSnapshotBeforeUpdate


in our case, we can execute the getting current position in our constructor and our componentDidMount methods. however it is a good practise to do your data loading in the componentDidMount method which is what we're going to do. we will refactor our code this way


componentDidMount() {
        window.navigator.geolocation.getCurrentPosition(
            position => {
                this.setState({lat: position.coords.latitude})
            },
            positionError => {
                this.setState({errorMessage: positionError.message})
            }
        )
    }


with this refactor, the job of our constructor now is to only initialize the state. due to this, we can use the alternative initializing state method

~ state = {lat: null, errorMessage:''}













??????QUESTION?????? display 'Burr it's chilly' if its winter or 'Let's hit the beach' if summer based on the latitude and month using the function below
const getSeason = (lat, month) => {
  if (month>2 && month <9){
    return lat > 0 ? 'summer' : 'winter'
  } else return lat > 0 ? 'winter' : 'summer'
}
??????QUESTION?????? make the text displayed large











moving on with the app, we want to display the season to the user instead of the latitude


~ import SeasonDisplay from "./SeasonDisplay";

in the render function of our class, we will replace where we were printing out the latitude with the SeasonDisplay component. we will also pass the latitude from the state as a prop

~ else if (!this.state.errorMessage && this.state.lat{
        return <SeasonDisplay lat={this.state.lat} />
    }


we will now move on to logic for finding the season based on our latitude and month


in SeasonDisplay.js, we will create a function called getSeason outside the SeasonDisplay component. this is a good practice as we should write all the logic of our code outside the functional component code


const getSeason = (lat, month) => {
  if (month>2 && month <9){
    return lat > 0 ? 'summer' : 'winter'
  } else return lat > 0 ? 'winter' : 'summer'
}


we will call this function in our SeasonDisplay component and based on the season print some text to show the season

const SeasonDisplay = (props) => {

  const season = getSeason(props.lat, new Date().getMonth())
  const text = season === 'summer' ? "Let's hit the beach!" : "Burr, it's chilly!"

  return (
      <div>
        <h1>{text}</h1>
      </div>
  )
}













??????QUESTION?????? add snowflake or sun icons from semantic ui before and after the text. refactor the code to avoid repetition when checking for the season and what to display
??????QUESTION?????? make the icons you've added big













we will then add some icons from semantic ui to show the season. this will mean that we create another ternary operator which makes the code kind of repetitive


to counter this, we will create an object with summer and winter properties whose values will be the properties of of the respective season


we will give the exact names summer and winter as keys so that it becomes easy to reference the keys


we will also destructure this and save them in variables

const seasonConfig = {
    summer: {
        text: `Let's go to the beach`,
        iconName: 'sun'
    },
    winter: {
        text: `Burr, it's chilly`,
        iconName: 'snowflake'
    }
}


const SeasonDisplay = (props) => {

    const season = getSeason(props.lat, new Date().getMonth())

    const {text, iconName} = seasonConfig[season]

    return (
        <div>
            <i className={`massive ${iconName} icon`}/>
            <h1>{text}</h1>
            <i className={`massive ${iconName} icon`}/>
        </div>
    )
}














??????QUESTION?????? create a SeasonDisplay.css file and place the first icon top left and second icon bottom right. center the text
??????QUESTION?????? add the following styles too
                        winter          summer
background colour       aquablue        orange
icon                    blue            red













we're now going to add some styling, inside the src folder create a css file called SeasonDisplay.css


we'll add icon-left and icon-right class to the icons then use positioning to position them top left and bottom right respectively


.icon-left{
    position: absolute;
    top: 10px;
    left: 10px;
}

.icon-right{
    position: absolute;
    bottom: 10px;
    right: 10px;
}



we will then import this css file in SeasonDisplay.js



we're going to have a theme based on the season, blue for winter and orange for summer. to do this we'll add a class to the first div of our SeasonDisplay component.

<div className={`season-display ${season}`}>


center the text and add the background color by adding the following css

.season-display{
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
}

.winter{
    background-color: aliceblue;
}

.summer{
    background-color: orange;
}

.season-display.winter i{
    color: blue;
}

.season-display.summer i{
    color: red;
}










??????QUESTION?????? create a component called spinner using semantic ui and use it instead of the loading text while waiting for the use to give permission to access their location
??????QUESTION?????? make the spinner dynamic and pass in custom text. also make it show default text loading... in the case custom text is not passed
??????QUESTION?????? reformat the conditional code in the render function in index.js and place it in a separate function
















we're now going to create a component for showing the loader


create Spinner.js and get the spinner code from semantic ui

import React from "react";

const Spinner = () => {
    return (
        <div className="ui active inverted dimmer">
            <div className="ui big text loader">
                Loading...
            </div>
        </div>
    )
}

export default Spinner


import this and use it instead of the loading text



we will then make this dynamic and pass the text we want to show in the app component.


this makes it reusable, however it will be even much better if we could add some default text in the case where the message isn't passed when the component is referenced


we'll do this by setting a default value for the prop

Spinner.defaultProps ={
    message: 'Loading...'
}



our code is now looking good, however there's one improvement that we can make



in our index.js render has conditional code, this makes the code rigid in the case we want to make changes in future


the goal is to have a return statement in our render function


we will transfer the conditional code in a separate function and pass the function in our render function

note the use of this when refering to the renderContent method inside the render function

    renderContent(){
        if (this.state.errorMessage && !this.state.lat){
            return <div>Error: {this.state.errorMessage}</div>
        } else if (!this.state.errorMessage && this.state.lat){
            return <SeasonDisplay lat={this.state.lat} />
        } else return <Spinner message="Please accept location request"/>
    }

    render() {
        return(
            <div>
                {this.renderContent()}
            </div>
        )
   }

















??????QUESTION?????? create a new react project called pics
??????QUESTION?????? do a more organized component set up and print out app
??????QUESTION?????? create another component called search bar which will be used to handle the user input. this should guide you on which type of component to create. the app should print a text input from the search bar component instead of the previous text
??????QUESTION?????? add semantic ui to the project
??????QUESTION?????? do the following styling for the SearchBar component
        <div className="ui segment">
            <form className="ui form">
                <label>Image Search</label>
                <input type="text"/>
            </form>
        </div>
??????QUESTION?????? add the following styling to the App component
      <div className="ui container" style={{marginTop: '10px'}}>
        <SearchBar />
      </div>
















///////  HANDLING USER INPUTS WITH FORMS AND EVENTS ///////

create a new react app called pics


our app is going to get a search term from the user, use an api to fetch images related to that search term then display those images on the screen



we'll create a SearchBar component that is responsible for showing a text input at the very top of the screen


we'll also have a second component called the ImageList which will take a list of images and render them out


go inside the pics app we created, delete all the src files and create an index.js file as usual



this time we'll have something different instead of our usual boilerplate code in index.js


we know before hand that we'll have several components and several css files. with this in mind the src folder might get a little messy


we'll create a folder called components where we'll store all our components including the App component


in the components folder create App.js which will print out App. export it and import it in index.js


render the App component in index.js



now create a new component called SearchBar in the components folder


this will show the input and we know that this will be a class based component as we know we'll have to use state to handle the user input


for now we'll just make it return a input text element wrapped inside a form, export and import in App component rather than showing the App text



we'll now do some styling using semantic ui. add the cdn in index.html


add the following classes to the search bar component
        <div className="ui segment">
            <form className="ui form">
                <label>Image Search</label>
                <input type="text"/>
            </form>
        </div>


do the following styling in the app component
      <div className="ui container" style={{marginTop: '10px'}}>
        <SearchBar />
      </div>















??????QUESTION?????? add a function called onInputChange which detects when a user enters some input and console log it
??????QUESTION?????? what is the alternate syntax for handling the onChange prop and when is it used











we're now going to add some event handlers to detect when a user enters some input


in the SearchBar component, we'll create an onInputChange function which will be called when there's an input change. this is possible by adding this function as a prop to onChange={this.onInputChange}


note that despite on inputChange being a function, we do not call it i.e. onInputChange() as this will run the function everytime the component is rendered. we dont put the call () and leave the function to be called only when there's an input change


this callback will be run with the event argument passed to it automatically


the property that we care the most about is event.target.value which will contain the text that the user added to the input


other similar props to onChange include onClick and onSubmit




we'll refactor our code to use an alternate event handling syntax


this is mostly used when our event handling is a single line of code. in this case we're only console logging the event.target.value therefore it can be a good use case


you basically write the function inside the jsx
~ onChange={ e => console.log(e.target.value) }













??????QUESTION?????? what is the difference between controlled elements and uncontrolled elements
??????QUESTION?????? convert the input element to a controlled element














there are two types of elements which we do event handling on, controlled elements which is what most react developers prefer using and uncontrolled elements which is like the input element we're currently using


we'll refactor our code and convert the element from uncontrolled to controlled


delete the onInputChange function. initialize state which will have a property called term which will default into an empty string

~ state = { term: '' }


we'll then modify our onChange prop, do an inline arrow function and setState term to the value entered by the user

~ onChange = { e => this.setState{ term: e.target.value }}


we'll also add a new prop on the input element called value which we'll set to term from the state
~ value = {this.state.term}


the flow of our app now is
- user types in input
- callback gets invoked
- we setState with the new value
- component rerenders
- input value is updated to the updated value from state


this is what constitutes a controlled element


for the uncontrolled element, react has no idea on what the value of the input is as much as it's available in html. the only way we can access the input value in react is if we reach out to the dom and pull the value


storing information inside html is not a good practise that's why we use controlled elements which centralizes the information in the react world



onChange={event => this.setState({password: event.target.value})}
value = {this.state.password}










??????QUESTION?????? what is the default behaviour when a user submits the form
??????QUESTION?????? prevent this default behaviour
??????QUESTION?????? console log the value in the onFormSubmit function
??????QUESTION?????? what are the two ways you can use to solve the this error in a class component












our SearchBar now knows what the user is typing. we will now start working on submitting


we will need to figure out when the submission is made or in other terms when the user presses the enter key


for now when we press enter, the default behaviour of the browser is to try and submit the form to a backend server of sorts


we don't have a backend server so in this case the page will kind of refresh and our input will be lost


we want to stop this default behaviour and instead run some custom logic of our own


create an onSubmit prop in the form element which will call onFormSubmit method
~ onSubmit={this.onFormSubmit}

create this onFormSubmit method and first disable the default behaviour
~   onFormSubmit(event){
        event.preventDefault();
    }




if we try and console log the value of term from the state, we will be met with an error
Cannot read properties of undefined (reading 'state')


this is because the value of this changes to the function onFormSubmit and not the class SearchBar which is undefined



there are several ways of fixing this issue


one way of solving this is by binding the onFormSubmit function in the constructor

constructor(){
    this.onFormSubmit = this.onFormSubmit.bind(this)
}


another way of solving this is by using an arrow function which automatically binds the value of this for all the code inside the function i.e an arrow function doesn't have it's own this value

onFormSubmit = (event) => {
    ...
}














??????QUESTION?????? explain how you would pass the search term from the SearchBar component to the App component
??????QUESTION?????? pass the search term to the App component and console log it

















it's not really the work of the SearchBar component to fetch the results of the search. this would be the work of the App component instead


we'll need to figure out a way of communicating this search result from the child component SearchBar back to the parent App component


to do this we're going to convert our App component to a class component then define a onSearchSubmit callback function


whenever the App component shows the SearchBar, it is going to pass the onSearchSubmit function as a prop to the SearchBar component


when a user submits the form, it is going to call the callback function onSearchSubmit with the search term


this is very similar to the onChange and the onSubmit event handlers we have been using



refactor the App component to a class based component


create a function called onSearchSubmit on the class which gets called with the search term
~ onSearchSubmit(term){
        console.log(term)
  }


we'll then pass this as a prop on SearchBar
~ <SearchBar onSubmit={this.onSearchSubmit} />


the onSubmit prop for a component isn't similar to the onSubmit on an element an we could have as well given it any other name other than onSubmit
~ <SearchBar searchSubmitted={this.onSearchSubmit} />


we will then reference this callback in SearchBar onFormSubmit function which we'll be able to reference using the prop name passed i.e. props.searchSubmitted


something to note is that everytime we've used a prop so far it has been in a functional component

referencing a prop in a functional component
~ props.searchSubmitted

referencing a prop in a class component
~ this.props.searchSubmitted









??????QUESTION?????? install axios to your project and use it to fetch images of the search term and print below the search bar the number of images found from our search












/////       MAKING API REQUESTS WITH REACT      /////

we will be using unsplash api to get the images


go to unsplash developers and log in and create a new application


for full documentation of what we'll be using go to documentation > search photos


we will use axios to do our fetch requests

~ npm i axios

import axios from 'axios' //app.js


we will use the axios.get method which accepts two arguments, first the address where we want to make the get request to i.e. /search/photos and secondly an object which will help us customize this request


    async onSearchSubmit(term){
        const response = await axios.get('https://api.unsplash.com/search/photos', {
            params: { query: term },
            headers: {
                Authorization: 'Client-ID 1zf5l5lJZAHMIxHRseDydPkX-3Di_dAquqRweRCv-RQ'
            }
        });
    }



we will update the state with the result of the request in order to make our component rerender itself again

~ state = { images: [] }
initialize state at the top of the class

~ this.setState({images: response.data.results})
inside the onSearchSubmit function

~ Found: {this.state.images.length} images
for now we will print out the number of images found inside the render function

this will however cause an error as the this value isn't for the class but instead the onSearchSubmit function


correct this by converting the onSearchSubmit function into an arrow function

    onSearchSubmit = async (term) => {
        const response = await axios.get('https://api.unsplash.com/search/photos', {
            params: { query: term },
            headers: {
                Authorization: 'Client-ID 1zf5l5lJZAHMIxHRseDydPkX-3Di_dAquqRweRCv-RQ'
            }
        });

        this.setState({images: response.data.results})
    }


















we will now refactor our code to remove all the axios code in our App


create a folder called api in the src directory, create unsplash.js


we will put all the code related to configuration of unsplash to accept our axios request here


in unsplash.js, import axios


one good thing about axios is that we can set up a pre-configured instance of the axios client that has default properties set for where it is going to make the request to, headers, params etc


export default axios.create({
    baseURL: 'https://api.unsplash.com',
    headers: {
        Authorization: 'Client-ID 1zf5l5lJZAHMIxHRseDydPkX-3Di_dAquqRweRCv-RQ'
    }
})


we'll now import this instead of axios

import unsplash from '../api/unsplash'

then call this instead of axios

    const response = await unsplash.get('/search/photos', {
        params: { query: term },
    });










??????QUESTION?????? create a function component called ImageList which will receive the images from App component. render these images to make sure it worked well
??????QUESTION?????? make sure you have no errors or warnings in your console
??????QUESTION?????? use destructuring when mapping the images list for cleaner code













////        RENDERING THE IMAGES ON THE SCREEN   /////


create a functional component called ImageList with random text and import it to the App component and show it on the app


we will then pass the list of images from the App component to the ImageList component i.e. parent to child which we do using props
~ < ImageList images={this.state.images} />

we will then use a map to loop through all the images and print them

    const images = props.images.map(
        image => <img src={image.urls.regular} />
    )

    return (
        <div>
            {images}
        </div>
    )


this will now work, however it will throw a warning in the console that each child in a list should have a unique "key" prop


this is because when react is trying to render an item in a list, it will look for it in the dom. looking for it means it will check all the existing items in the dom if it exists so that it can update or not


having each item in a list containing a key means react will be able to look for the items more quickly and it improves the performance


we will then add the key/ id in the root tag of every item in our list i.e. the highest level element in our list


we happen to get ids from our results from unsplash at images.id

we'll also add description from the images to get rid of the alt warning

~ return <img alt={image.description} key={image.id} src={image.urls.regular} />


you can further simplify the code by destructuring from the map to reduce code repetition

const ImageList = (props) => {
    const images = props.images.map(({description, id, urls}) =>
    {
        return <img alt={description} key={id} src={urls.regular}/>
    }
)

























??????QUESTION?????? create ImageList.css in the components folder and import it in the ImageList component
??????QUESTION?????? give the root of the ImageList component a class name of image-list and add the following css
.image-list{
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
    grid-gap: 10px;
}

.image-list img {
    width: 250px;
}
??????QUESTION?????? what is a grid-auto-row and grid-row-end. explain how we can use this to reduce the white vertical space and why this using css only may not be enough to fix the white vertical space
??????QUESTION?????? create a new component called ImageCard and use it to print the image instead of the image tag in the ImageList component



















////        STYLING THE IMAGES      /////


we will use the grid css system

in the components' folder create a file called ImageList.css and import it in the ImageList component


add a class image-list to the root of our component

.image-list{
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
    grid-gap: 10px;
}

.image-list img {
    width: 250px;
}



grid-template-columns creates a set number of columns

auto-fill will decide how many columns to insert

minmax(250px, 1fr) means each column will be at minimum 250px wide and the maximum allocation of space wide


we're going to try and fix the vertical white spaces between the images

we can use grid-auto-rows to specify the height of an image and grid-row-end with span to specify how many grid spaces the image will occupy


however, this is difficult to do with css as all the images have varying heights


we will use react for this as we'll need to calculate the height of very image and based on this height determine the number of spans to be allocated


create a new react class component called ImageCard which will be responsible for rendering one image at a time


it will figure out the height of the image and based on this determine the grid-row-end span to accomodate for the size


class ImageCard extends React.Component{
    render() {
        const {description, urls} = this.props.image
        return (
            <div>
                <img alt={description} src={urls.regular} />
            </div>
        );
    }
}


also modify the images map now that we'll be passing our attributes and src to our component


note that we still have to pass the key however and we can not pass it to the component ImageCard

    const images = props.images.map((image) =>
        {
            return <ImageCard key={image.id} image={image}/>
        }
    )
















??????QUESTION?????? create a react ref for the image and console log the height of each image

















we will now use our ImageCard component to dynamically calculate the size of an image in the following steps
- we will let the ImageCard render itself and its image
- reach into the DOM and figure out the height of the image
- set the image height on state to get the component to rerender
- when rerendering, assign grid-row-end to make sure the image takes up the appropriate space



in vanilla js we can access the dom using document.querySelector etc


in react this is different and we use the ref system instead


it gives you access to a single dom element


we create refs in the constructor, assign them to instance variables, then pass to a particular JSX element as props


we don't necessarily have to store them in state cause their values won't change


in ImageCard class add the following code

constructor(props){
    super(props);

    this.imageRef = React.createRef();
}

then pass it as a ref in the render function image element

<img ref={this.imageRef} alt{description} src={urls.regular} />


now anywhere inside this component, we can reference this.imageRef and it will tell us about the img element


we will access this in the componentDidMount method where we will first wait for it to load and for now we'll just console log the heights


    componentDidMount() {
        this.imageRef.current.addEventListener('load', this.setSpans)
    }

    setSpans = () => {
        console.log(this.imageRef.current.clientHeight)
    }














??????QUESTION?????? with this height, use grid-auto-rows and grid-row-end to get rid of the vertical white space between the images












with this height, we can now calculate the number of spans that will be needed for each image


first add a grid-auto-row: 10px at image-list
this means each grid container will have a height of 10px


with smaller rows, this means the whitespaces will be smaller and more accurate


we'll then dynamically set the grid-row-end with a span of the number of grid containers it will need to cover its height comfortably

ImageCard.js

import React from 'react'

class ImageCard extends React.Component{
    constructor(props) {
        super(props);

        this.state = ({spans: 0})

        this.imageRef = React.createRef()
    }

    componentDidMount() {
        this.imageRef.current.addEventListener('load', this.setSpans)
    }

    setSpans = () => {
        const height = this.imageRef.current.clientHeight

        const spans = Math.ceil(height/ 10)

        this.setState({spans})
    }

    render() {
        const {description, urls} = this.props.image
        return (
            <div style={{gridRowEnd: `span ${this.state.spans}`}}>
                <img ref={this.imageRef} alt={description} src={urls.regular} />
            </div>
        );
    }
}

export default ImageCard



ImageList.css

.image-list{
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
    grid-gap: 0 10px;
}

.image-list img {
    width: 250px;
}








