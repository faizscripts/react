






??????QUESTION?????? explain how react works
??????QUESTION?????? what are the two react libraries necessary to run a react project and what is their roles
??????QUESTION?????? what is useState

the app function is called a react component
it produces jsx and handles user events
it returns jsx which is html content which shows on the screen
jsx can show a normal html element or show react components

the browser makes a request to the server and it gets back an index.html file which is stored in the public folder, the index file contains scripts which tells the browser to get all the js files i.e app.js, index.js and the react components which are bundled together into a bundle.js file

this js is then converted to html and placed in the index.html file

the first js file that gets executed is index.js which sets up the project.

it calls the app function <App/> and index.html which contains an ID tag root document.getElementById("root") in this case

ReactDOM.render(<App/>, document.getElementById("root"))

whenever were working with react, we work with two separate libraries i.e React and ReactDOM

React works with components and it's called a reconciler

ReactDOM turns instructions into html and it's called a renderer

useState is a function for working with react's state system. state is used to keep track of data that changes over time. it makes react update the html on the screen













??????QUESTION?????? create a react project called jsx and explain the project structure
??????QUESTION?????? delete all the files in the src folder and make the app display Hello React








~ npx create-react-app projectName
installs create-react-app and creates a new project in one command


we use create-react-app because it installs for us a ton of dependencies that we don't have to install manually and are important for the running of a react application e.g babel, webpack, dev server


the create-react-app gives us a project structure which consists of the following files

src folder - where we put all the source code we write
public folder - stores static files e.g images
node_modules
package.json
readme


~ npm start
start create-react-app


delete everything in the src folder and create an index.js file

react 18 update

import React from "react";
import {createRoot} from "react-dom/client";

import App from "./components/App";

const container = document.querySelector("#root")
const root = createRoot(container)

root.render(<App />)

///////////////////////////////////////////////////

we will use three guidelines in our index.js file
1. import React and ReactDOM libraries
import React from 'react';
import ReactDOM from 'react-dom';

2. create a react component
a react component is a function or a class that produces HTML using JSX and handles feedback from the user using event handlers
const App = () => {
  return <div>Hello React</div>
}

3. show the react component on the screen
ReactDOM.render(<App/>, document.querySelector('#root'))

















??????QUESTION?????? what happens when you start the jsx of the app function on a new line, what is the way around for this for a multiline jsx block
??????QUESTION?????? convert the following piece of code to jsx. also instead of the submit text, create a variable string called click me and pass in the value instead
// <div>
//     <label for="name" class="label"> Enter name: </label>
//     <input id="name" type="text"/>
//     <button style="background-color:blue; color:white"> Submit </button>
// </div>
??????QUESTION?????? what type of variable doesn't work in jsx


















/// BUILDING CONTENT WITH JSX

jsx gets converted into normal looking js code by babel

jsx is similar to html but it differs in the following ways
1. adding custom styling uses a different syntax
    <div style="background-color:blue;"> </div>
    <div style={{backgroundColor: 'blue'}}> </div>

2. adding a class to an uses a different syntax, for attribute also uses htmlFor
    <label htmlFor="name" className="label"> Enter name: </label>

3. jsx can reference js variables
    {variableName}

///ANSWER
import React from 'react';
import ReactDOM from 'react-dom';

const App = () => {
    const buttonText = 'Click Me!'

  return (
      <div>
        <label htmlFor="name" className="label"> Enter name: </label>
        <input id="name" type="text"/>
        <button style= {{ backgroundColor:'blue', color:'white' }}> {buttonText}</button>
      </div>
  )
}

ReactDOM.render(<App/>, document.querySelector('#root'))



calling an object in the place of text will not work, you will need to reference the keys of the object instead
const buttonText = {text: 'Click me'}

{buttonText} will not work but {buttonText.text} will













??????QUESTION?????? create a react app called components, delete all the files in the src folder and make it print out hello world
??????QUESTION?????? load semantic ui to your project
??????QUESTION?????? add the following jsx in your app function
    <div className="ui container comments">
      <div className="comment">
        <a href="/" className="avatar">
          <img alt="avatar" />
        </a>
        <div className="content">
          <a href="/" className="author">
            Sam
          </a>
          <div className="metadata">
            <span className="date">Today at 6:00PM</span>
          </div>
          <div className="text">Nice blog post!</div>
        </div>
      </div>
    </div>
??????QUESTION?????? use faker to generate random fake images for the avatar of the comment, name, use month for date, and adjective for text (npm install @faker-js/faker, import {faker} from "@faker-js/faker";)











//// COMMUNICATING WITH PROPS   ////

in this section we're going to focus on 3 things
1. component nesting
2. component reusability
3. component configuration - configure a component when it is created


we're going to create a web app which displays a list of comments


create a new react app called components and delete all the src files

create and index.js file in src and import the necessary libraries and print out Hello world


we're going to use semantic ui for our styling.

google its cdn for the min.css and add it to index.html
an indication that the semantic ui has loaded is that you'll notice that the fonts in your page have changed

add the following jsx in your app function which utilizes semantic ui

    <div className="ui container comments">
      <div className="comment">
        <a href="/" className="avatar">
          <img alt="avatar" />
        </a>
        <div className="content">
          <a href="/" className="author">
            Sam
          </a>
          <div className="metadata">
            <span className="date">Today at 6:00PM</span>
          </div>
          <div className="text">Nice blog post!</div>
        </div>
      </div>
    </div>


we're going to avoid the hustle of downloading and referencing images to save time so instead we'll use a js library called faker.js which generates a massive amount of realistic fake data

~ npm install @faker-js/faker --save-dev

import { faker } from '@faker-js/faker';

        <div className="ui container comments">
            <div className="comment">
                <a href="/" className="avatar">
                    <img alt="avatar" src={faker.image.avatar()} />
                </a>
                <div className="content">
                    <a href="/" className="author">
                        {faker.name.findName()}
                    </a>
                    <div className="metadata">
                        <span className="date">{faker.date.month()}</span>
                    </div>
                    <div className="text">{faker.word.adjective()}</div>
                </div>
            </div>
        </div>
















??????QUESTION?????? execute the most viable way of creating multiple comments and create 3 comments with dynamic authors, time ago, text and image avatar
??????QUESTION?????? create an approval card component which creates a card outline around the comment with an option to approve or reject buttons for the comment. use the styles below
      <div className="ui card">
          <div className="content">
              // contents of the card i.e comment details and in the question below we will test it's reusability and pass random text instead
          </div>
          <div className="extra content">
              <div className="ui two buttons">
                  <div className="ui basic green button">Approve</div>
                  <div className="ui basic red button">Decline</div>
              </div>
          </div>
      </div>
??????QUESTION?????? to test reusability of the ApprovalCard, pass some text 'Are you sure' instead of the comment











one way of adding more comments is duplicating the comment code. as you can imagine, this will make the code untidy and difficult to manage


we're going to refactor this code to create reusable components


the series of steps to follow when creating reusable components are
- identify the duplicated jsx
- what is the purpose of the block of jsx? give it a descriptive name
- create a new file to house this component which will have the same name
- create a new component in the file and paste the jsx
- make the new component configurable by using react's props system




in the src folder create a new file called CommentDetail.js. usually react components are written in uppercase


import react and faker then create a function called CommentDetail which you'll paste the comment jsx

in order to use this file inside index.js we will have to export it and import it in index.js


export default CommentDetail;

import CommentDetail from './CommentDetail'

we will then make this component configurable by using reacts prop system


the prop system passes data from a parent component to a child component. the goal is to customize or configure a child component

<CommentDetail author="Sam" />

in the component detail function, the default argument props is an object which contains all the data passed from the parent in key and value pairs. in this case the props object will contain a key of author and the respective value passed by the parent.


this can be destructured at the argument level ({author}) the the variable author called where we were hardcoding the author value

      <a href="/" className="author">
          {author}
      </a>



we're now going to look at props reusability. we're going to create an approval card for the comments where the admin can approve or reject the comments


we'll create another component called approval card which will contain an outline around the comment with two buttons. we will use this together with the CommentDetail component


create ApprovalCard.js inside src folder and add the necessary boilerplate code with card styling from semantic ui

const ApprovalCard = (props) => {
  return (
          <div className="ui card">
              <div className="content">
                  {props.children}
              </div>
              <div className="extra content">
                  <div className="ui two buttons">
                      <div className="ui basic green button">Approve</div>
                      <div className="ui basic red button">Decline</div>
                  </div>
              </div>
          </div>
  )
}


the ApprovalCard component in index.js will have opening and closing tags which will enable us to access the CommentDetail as a child when passed in between the tags


        <ApprovalCard>
            <CommentDetail author={faker.name.findName()} timeAgo="Today at 4.45PM" text="Awesome stuff" avatar={faker.image.avatar()}/>
        </ApprovalCard>


the approval card is reusable and it can even be passed some plain text or html instead of the comment

        <ApprovalCard>Are you sure?</ApprovalCard>

        <ApprovalCard>
            <div>
                <h4>Are you sure in HTML</h4>
            </div>
        </ApprovalCard>

















??????QUESTION?????? what are the two different types of components and what is the difference between them
??????QUESTION?????? create a new react project called seasons, link up semantic ui to the project
??????QUESTION?????? for starting, we will use two function based components. create an App component which prints out App Component and a SeasonDisplay component which prints out Seasons






//////  STRUCTURING APPS WITH CLASS BASED COMPONENTS    ///














there are two types of components, function and class components


functional components
1. can produce jsx to show content to the user
2. can use hooks to run code at specific points in time
3. can use hooks to access state system and update content on screen
4. good for simple content


class components
1. can produce jsx to show content to the user
2. can use lifecycle method system to run code at specific points in time
3. can use the state system to update content on the screen
4. good for just about everything else


if both components have almost the same capabilities, it begs the question, which one should we use


old projects most likely run with class based components as function based components had restricted use in the past


newer projects may be using class based or function based components


we're going to create a simple react app to understand this. the app is going to check the users location and month then print the season the user is currently experiencing


create a new project called seasons and link it up with semantic ui


delete files in src and create index.js


for starting we will have two components, an app component which has code to determine location + month and a seasons display component which shows different text/ icons based on props


in the index.js write the necessary boilerplate code and print Hello World


also create another file called SeasonDisplay.js which prints out season












??????QUESTION?????? use window.navigator.geolocation.getCurrentPosition() in the App component to get the users location. it accepts two callback functions, use them to console log the result and the error
??????QUESTION?????? what is the issue of using a function based component with this callback function











we're now going to look at how to get the users physical location using functions that are build into most modern browsers


this is Geolocation API


    window.navigator.geolocation.getCurrentPosition(
        position => console.log(position),
        positionError => console.log(positionError)
    )
gets the location, however it takes time so you'll have to use a callback function


add this to your App function


the getting location function takes some time to execute. however our function will continue execution and return jsx which will make it impossible to get back to our callback function



















??????QUESTION?????? what are the 3 rules of a class based component
??????QUESTION?????? refactor the App component to a class based component
??????QUESTION?????? initialize the state system which will have a property lat with value null using constructor method
??????QUESTION?????? why do we use the super function
??????QUESTION?????? how can you access the values in your state













one way around this is using class based components and react state system where once after getting the result of the geolocation we will tell the app to rerender itself with this new information


a class based component follows the following rules
1. must be a js class
2, must extend React.Component class
3. must define a render method that returns some amount of jsx


class App extends React.Component{
    render(){
        return <div>This is a class based component</div>
    }
}


we extend from react component because react expects several other methods attached to it in order to work. however we don't have to create all of these therefore we borrow them from the React.Component class


in order to access the data from the callback which takes time to execute, we will use the state system


rules of the state system
1. only usable with class components (*might technically be used with functional components but this will be further discussed later)
2. don't confuse props with state
3. state is a js object that contains data relevant to a component
4. state must be initialized when a component is created
5. updating state on a component causes the component to (almost) instantly rerender
6. state can only be updated using the function setState




in order to initialize state when our component is created, we will use a constructor function which normally is the first function called in a class


there are other ways of initializing a state but for now we will just start with this constructor way


the constructor method will be automatically called with the props object


~ super(props)
we will then call a function called super which is borrowed from the parent class React.Component and pass the props. this will make sure that the constructor method in the parent class is called


~ this.state = { lat: null }
this will initialize the state and since we know before hand that we will be using the latitude value from our callback function, we will create a property lat and set its value to null



    constructor(props) {
        super(props);

        this.state = { lat: null}
    }


~ {this.state.lat}
after initializing the state, we can access it from anywhere inside our class based component
















??????QUESTION?????? refactor the getting latitude function so that it doesn't get called everytime our component is rendered and instead called when the component is created for the first time and avoid the repetition. why is this refactor important
??????QUESTION?????? update the value of state to the latitude result of the callback and print it out on the screen
??????QUESTION?????? create another property of our state called errorMessage. in the case an error occurs update the value of errorMessage to store the error from the callback (you can cause an error by denying location permission in the browser)
??????QUESTION?????? edit the render function to print the latitude value if its present, the error message if an error occurred or loading is the results haven't been fetched yet




















if we update our state after we get the results from our callback function, this will make the component to rerender and we will be able to access the latitude value



note that the rerendering will cause the getCurrentPosition function to be called all the time. due to this we will move it to our constructor so that it is called when the component is created for the first time and avoid the repetition. i think you can also use componentDidMount



~ this.setState({lat: position.coords.latitude})
we will also update our state to get the value of latitude from our callback function. the console log isn't necessary at this point



create another property of our state called errorMessage. in the case an error occurs update the value of errorMessage to store the error from the callback

~ this.state = { lat: null, errorMessage: ''}

~   positionError => {
         this.setState({errorMessage: positionError.message})
    }


edit the render function, add a new line which prints out the value of the error message

~    render() {
         return (
             <div>
                 Latitude: {this.state.lat}
                 <br/>
                 Error: {this.state.errorMessage}
             </div>
         )
     }



the code now works well, however printing out the word error all the time doesn't look good


we will look at the scenarios that can occur with our latitude situation
1. have latitude, no errorMessage   - show latitude
1. no latitude, have errorMessage   - show errorMessage
1. no latitude, no errorMessage     - show loading...



we can implement this using an if statement in our render function

   render() {
        if (this.state.errorMessage && !this.state.lat){
            return <div>Error: {this.state.errorMessage}</div>
        } else if (!this.state.errorMessage && this.state.lat){
            return <div>Latitude: {this.state.lat}</div>
        } else return <div>Loading...</div>
   }



alternative solution, create a function and call in in the render function using this.printLat
    printLat(){
        if (this.state.lat) return <p>Latitude: {this.state.lat}</p>

        if (this.state.errorMessage) return <p>Error: {this.state.errorMessage}</p>

        return <p>Loading ...</p>
    }



















??????QUESTION?????? describe the component lifecycle with all the methods associated to it. explain what the methods are used for
??????QUESTION?????? do all the data loading in the componentDidMount method
??????QUESTION?????? use the alternative way of initializing the state












we're going to refactor our code and initialize our state using an alternative way


in order to do this we need to understand life cycle methods


-the component starts with a constructor then the render method is called. the content now becomes visible on the screen. in the render method, avoid doing anything besides returning jsx
- a componentDidMount function is then automatically called, this is called once when our component is rendered on the screen for the first time. this is a good place to do data loading
- our component will now sit and wait for updates
- when an update happens on our state, the component is rerendered and a componentDidUpdate function is called automatically. this is a good place to do more data loading when state/ props change
- this update cycle is then repeated until the component is no longer shown where a componentWillUnmount function will be automatically called. this is a good place to do clean up especially for non react stuff


there are 3 other lifecycle methods but they're rarely used
1. shouldComponentUpdate
2. getDerivedStateFromProps
3. getSnapshotBeforeUpdate


in our case, we can execute the getting current position in our constructor and our componentDidMount methods. however it is a good practise to do your data loading in the componentDidMount method which is what we're going to do. we will refactor our code this way


componentDidMount() {
        window.navigator.geolocation.getCurrentPosition(
            position => {
                this.setState({lat: position.coords.latitude})
            },
            positionError => {
                this.setState({errorMessage: positionError.message})
            }
        )
    }


with this refactor, the job of our constructor now is to only initialize the state. due to this, we can use the alternative initializing state method

~ state = {lat: null, errorMessage:''}













??????QUESTION?????? in SeasonDisplay component display 'Burr it's chilly' if its winter or 'Let's hit the beach' if summer based on the latitude and month using the function below
const getSeason = (lat, month) => {
  if (month>2 && month <9){
    return lat > 0 ? 'summer' : 'winter'
  } else return lat > 0 ? 'winter' : 'summer'
}
??????QUESTION?????? make the text displayed large











moving on with the app, we want to display the season to the user instead of the latitude


~ import SeasonDisplay from "./SeasonDisplay";

in the render function of our class, we will replace where we were printing out the latitude with the SeasonDisplay component. we will also pass the latitude from the state as a prop

~ else if (!this.state.errorMessage && this.state.lat{
        return <SeasonDisplay lat={this.state.lat} />
    }


we will now move on to logic for finding the season based on our latitude and month


in SeasonDisplay.js, we will create a function called getSeason outside the SeasonDisplay component. this is a good practice as we should write all the logic of our code outside the functional component code


const getSeason = (lat, month) => {
  if (month>2 && month <9){
    return lat > 0 ? 'summer' : 'winter'
  } else return lat > 0 ? 'winter' : 'summer'
}


we will call this function in our SeasonDisplay component and based on the season print some text to show the season

const SeasonDisplay = (props) => {

  const season = getSeason(props.lat, new Date().getMonth())
  const text = season === 'summer' ? "Let's hit the beach!" : "Burr, it's chilly!"

  return (
      <div>
        <h1>{text}</h1>
      </div>
  )
}















??????QUESTION?????? add snowflake or sun icons from semantic ui before and after the text. refactor the code to avoid repetition when checking for the season and what to display
        <div>
            <i className={`massive ${iconName} icon`}/>
            <h1>{text}</h1>
            <i className={`massive ${iconName} icon`}/>
        </div>
the iconName for summer is 'sun' and the iconName for winter is 'snowflake'
??????QUESTION?????? make the icons you've added big













we will then add some icons from semantic ui to show the season. this will mean that we create another ternary operator which makes the code kind of repetitive


to counter this, we will create an object with summer and winter properties whose values will be the properties of of the respective season


we will give the exact names summer and winter as keys so that it becomes easy to reference the keys


we will also destructure this and save them in variables

const seasonConfig = {
    summer: {
        text: `Let's go to the beach`,
        iconName: 'sun'
    },
    winter: {
        text: `Burr, it's chilly`,
        iconName: 'snowflake'
    }
}


const SeasonDisplay = (props) => {

    const season = getSeason(props.lat, new Date().getMonth())

    const {text, iconName} = seasonConfig[season]   // the [] is used to access a variable in an object which happens to be an object which we will destructure

    return (
        <div>
            <i className={`massive ${iconName} icon`}/>
            <h1>{text}</h1>
            <i className={`massive ${iconName} icon`}/>
        </div>
    )
}














??????QUESTION?????? create a SeasonDisplay.css file and place the first icon top left and second icon bottom right. center the text
??????QUESTION?????? add the following styles too
                        winter          summer
background colour       aliceblue        orange
icon                    blue            red













we're now going to add some styling, inside the src folder create a css file called SeasonDisplay.css


we'll add icon-left and icon-right class to the icons then use positioning to position them top left and bottom right respectively


.icon-left{
    position: absolute;
    top: 10px;
    left: 10px;
}

.icon-right{
    position: absolute;
    bottom: 10px;
    right: 10px;
}



we will then import this css file in SeasonDisplay.js



we're going to have a theme based on the season, blue for winter and orange for summer. to do this we'll add a class to the first div of our SeasonDisplay component.

<div className={`season-display ${season}`}>


center the text and add the background color by adding the following css

.season-display{
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
}

.winter{
    background-color: aliceblue;
}

.summer{
    background-color: orange;
}

.season-display.winter i{
    color: blue;
}

.season-display.summer i{
    color: red;
}










??????QUESTION?????? create a component called spinner using semantic ui and use it instead of the loading text while waiting for the use to give permission to access their location
        <div className="ui active inverted dimmer">
            <div className="ui big text loader">
                Loading...
            </div>
        </div>
??????QUESTION?????? make the spinner dynamic and pass in custom text. also make it show default text loading... in the case custom text is not passed
??????QUESTION?????? reformat the conditional code in the render function in index.js/ App depending on your set up and place it in a separate function
















we're now going to create a component for showing the loader


create Spinner.js and get the spinner code from semantic ui

import React from "react";

const Spinner = () => {
    return (
        <div className="ui active inverted dimmer">
            <div className="ui big text loader">
                Loading...
            </div>
        </div>
    )
}

export default Spinner


import this and use it instead of the loading text



we will then make this dynamic and pass the text we want to show in the app component.


this makes it reusable, however it will be even much better if we could add some default text in the case where the message isn't passed when the component is referenced


we'll do this by setting a default value for the prop after our function Spinner

Spinner.defaultProps ={
    message: 'Loading...'
}



our code is now looking good, however there's one improvement that we can make



in our index.js render has conditional code, this makes the code rigid in the case we want to make changes in future


the goal is to have a return statement in our render function


we will transfer the conditional code in a separate function and pass the function in our render function

note the use of this when refering to the renderContent method inside the render function

    renderContent(){
        if (this.state.errorMessage && !this.state.lat){
            return <div>Error: {this.state.errorMessage}</div>
        } else if (!this.state.errorMessage && this.state.lat){
            return <SeasonDisplay lat={this.state.lat} />
        } else return <Spinner message="Please accept location request"/>
    }

    render() {
        return(
            <div>
                {this.renderContent()}
            </div>
        )
   }

















??????QUESTION?????? create a new react project called pics
??????QUESTION?????? do a more organized component set up and print out app
??????QUESTION?????? create a class component called SearchBar which will print SearchBar. App should print a text input from the SearchBar component
??????QUESTION?????? add semantic ui to the project
??????QUESTION?????? add the following styling for the SearchBar component
        <div className="ui segment">
            <form className="ui form">
                <label>Image Search</label>
                <input type="text"/>
            </form>
        </div>
??????QUESTION?????? add the following styling to the App component
      <div className="ui container" style={{marginTop: '10px'}}>
        <SearchBar />
      </div>
















///////  HANDLING USER INPUTS WITH FORMS AND EVENTS ///////

create a new react app called pics


our app is going to get a search term from the user, use an api to fetch images related to that search term then display those images on the screen



we'll create a SearchBar component that is responsible for showing a text input at the very top of the screen


we'll also have a second component called the ImageList which will take a list of images and render them out


go inside the pics app we created, delete all the src files and create an index.js file as usual



this time we'll have something different instead of our usual boilerplate code in index.js


we know before hand that we'll have several components and several css files. with this in mind the src folder might get a little messy


we'll create a folder called components where we'll store all our components including the App component


in the components folder create App.js which will print out App. export it and import it in index.js


render the App component in index.js



now create a new component called SearchBar in the components folder


this will show the input and we know that this will be a class based component as we know we'll have to use state to handle the user input


for now we'll just make it return a input text element wrapped inside a form, export and import in App component rather than showing the App text



we'll now do some styling using semantic ui. add the cdn in index.html


add the following classes to the search bar component
        <div className="ui segment">
            <form className="ui form">
                <label>Image Search</label>
                <input type="text"/>
            </form>
        </div>


do the following styling in the app component
      <div className="ui container" style={{marginTop: '10px'}}>
        <SearchBar />
      </div>















??????QUESTION?????? add a function called onInputChange which detects when a user enters some input and console log it
??????QUESTION?????? what is the alternate syntax for handling the onChange prop and when is it used
??????QUESTION?????? what is the difference between controlled elements and uncontrolled elements
??????QUESTION?????? convert the input element to a controlled element










we're now going to add some event handlers to detect when a user enters some input


in the SearchBar component, we'll create an onInputChange function which will be called when there's an input change. this is possible by adding this function as a prop to onChange={this.onInputChange}


note that despite on inputChange being a function, we do not call it i.e. onInputChange() as this will run the function everytime the component is rendered. we dont put the call () and leave the function to be called only when there's an input change


this callback will be run with the event argument passed to it automatically


the property that we care the most about is event.target.value which will contain the text that the user added to the input


other similar props to onChange include onClick and onSubmit




we'll refactor our code to use an alternate event handling syntax


this is mostly used when our event handling is a single line of code. in this case we're only console logging the event.target.value therefore it can be a good use case


you basically write the function inside the jsx
~ onChange={ e => console.log(e.target.value) }



there are two types of elements which we do event handling on, controlled elements which is what most react developers prefer using and uncontrolled elements which is like the input element we're currently using


we'll refactor our code and convert the element from uncontrolled to controlled


delete the onInputChange function. initialize state which will have a property called term which will default into an empty string

~ state = { term: '' }


we'll then modify our onChange prop, do an inline arrow function and setState term to the value entered by the user

~ onChange = { e => this.setState{ term: e.target.value }}


we'll also add a new prop on the input element called value which we'll set to term from the state
~ value = {this.state.term}


the flow of our app now is
- user types in input
- callback gets invoked
- we setState with the new value
- component rerenders
- input value is updated to the updated value from state


this is what constitutes a controlled element


for the uncontrolled element, react has no idea on what the value of the input is as much as it's available in html. the only way we can access the input value in react is if we reach out to the dom and pull the value


storing information inside html is not a good practise that's why we use controlled elements which centralizes the information in the react world



onChange={event => this.setState({password: event.target.value})}
value = {this.state.password}










??????QUESTION?????? what is the default behaviour when a user submits the form
??????QUESTION?????? prevent this default behaviour
??????QUESTION?????? console log the value of input in the onFormSubmit function












our SearchBar now knows what the user is typing. we will now start working on submitting


we will need to figure out when the submission is made or in other terms when the user presses the enter key


for now when we press enter, the default behaviour of the browser is to try and submit the form to a backend server of sorts


we don't have a backend server so in this case the page will kind of refresh and our input will be lost


we want to stop this default behaviour and instead run some custom logic of our own


create an onSubmit prop in the form element which will call onFormSubmit method
~ onSubmit={this.onFormSubmit}

create this onFormSubmit method and first disable the default behaviour
~   onFormSubmit(event){
        event.preventDefault();
    }




if we try and console log the value of term from the state, we will be met with an error
Cannot read properties of undefined (reading 'state')


this is because the value of this changes to the function onFormSubmit and not the class SearchBar which is undefined



there are several ways of fixing this issue


one way of solving this is by binding the onFormSubmit function in the constructor

constructor(){
    this.onFormSubmit = this.onFormSubmit.bind(this)
}


another way of solving this is by using an arrow function which automatically binds the value of this for all the code inside the function i.e an arrow function doesn't have it's own this value

onFormSubmit = (event) => {
    event.preventDefault()

    console.log(this.state.term);
}














??????QUESTION?????? convert the App component to a class based component
??????QUESTION?????? explain how you would pass the search term from the SearchBar component to the App component
??????QUESTION?????? pass the search term to the App component and console log it

















it's not really the work of the SearchBar component to fetch the results of the search. this would be the work of the App component instead


we'll need to figure out a way of communicating this search result from the child component SearchBar back to the parent App component


to do this we're going to convert our App component to a class component then define a onSearchSubmit callback function


whenever the App component shows the SearchBar, it is going to pass the onSearchSubmit function as a prop to the SearchBar component


when a user submits the form, it is going to call the callback function onSearchSubmit with the search term


this is very similar to the onChange and the onSubmit event handlers we have been using



refactor the App component to a class based component


create a function called onSearchSubmit in App on the class which gets called with the search term
~ onSearchSubmit(term){
        console.log(term)
  }


we'll then pass this as a prop on SearchBar
~ <SearchBar onSubmit={this.onSearchSubmit} />


the onSubmit prop for a component isn't similar to the onSubmit on an element an we could have as well given it any other name other than onSubmit
~ <SearchBar searchSubmitted={this.onSearchSubmit} />


we will then reference this callback in SearchBar onFormSubmit function which we'll be able to reference using the prop name passed i.e. props.searchSubmitted


something to note is that everytime we've used a prop so far it has been in a functional component

referencing a prop in a functional component
~ props.searchSubmitted

referencing a prop in a class component
~ this.props.searchSubmitted









??????QUESTION?????? install axios to your project and use it to fetch images of the search term. save these images in a piece of state called images. print below the search bar the number of images found from our search
use the query below
axios.get('https://api.unsplash.com/search/photos', {
            params: { query: term },
            headers: {
                Authorization: 'Client-ID 1zf5l5lJZAHMIxHRseDydPkX-3Di_dAquqRweRCv-RQ'
            }
        });












/////       MAKING API REQUESTS WITH REACT      /////

we will be using unsplash api to get the images


go to unsplash developers and log in and create a new application


for full documentation of what we'll be using go to documentation > search photos


we will use axios to do our fetch requests

~ npm i axios

import axios from 'axios' //app.js


we will use the axios.get method which accepts two arguments, first the address where we want to make the get request to i.e. /search/photos and secondly an object which will help us customize this request


    async onSearchSubmit(term){
        const response = await axios.get('https://api.unsplash.com/search/photos', {
            params: { query: term },
            headers: {
                Authorization: 'Client-ID 1zf5l5lJZAHMIxHRseDydPkX-3Di_dAquqRweRCv-RQ'
            }
        });
    }



we will update the state with the result of the request in order to make our component rerender itself again

~ state = { images: [] }
initialize state at the top of the class

~ this.setState({images: response.data.results})
inside the onSearchSubmit function

~ Found: {this.state.images.length} images
for now we will print out the number of images found inside the render function

this will however cause an error as the this value isn't for the class but instead the onSearchSubmit function


correct this by converting the onSearchSubmit function into an arrow function

    onSearchSubmit = async (term) => {
        const response = await axios.get('https://api.unsplash.com/search/photos', {
            params: { query: term },
            headers: {
                Authorization: 'Client-ID 1zf5l5lJZAHMIxHRseDydPkX-3Di_dAquqRweRCv-RQ'
            }
        });

        this.setState({images: response.data.results})
    }















??????QUESTION?????? create a new folder in src called api, we will create a pre configured instance of axios that will have all the default parameters and only pass the last part of the url and the search term. we will then export this and use it in App
axios.create({
    baseURL: 'https://api.unsplash.com',
    headers: {
        Authorization: 'Client-ID 1zf5l5lJZAHMIxHRseDydPkX-3Di_dAquqRweRCv-RQ'
    }
})
??????QUESTION?????? use this in App instead
    const response = await unsplash.get('/search/photos', {
        params: { query: term },
    });








we will now refactor our code to remove all the axios code in our App


create a folder called api in the src directory, create unsplash.js


we will put all the code related to configuration of unsplash to accept our axios request here


in unsplash.js, import axios


one good thing about axios is that we can set up a pre-configured instance of the axios client that has default properties set for where it is going to make the request to, headers, params etc


export default axios.create({
    baseURL: 'https://api.unsplash.com',
    headers: {
        Authorization: 'Client-ID 1zf5l5lJZAHMIxHRseDydPkX-3Di_dAquqRweRCv-RQ'
    }
})


we'll now import this instead of axios

import unsplash from '../api/unsplash'

then call this instead of axios

    const response = await unsplash.get('/search/photos', {
        params: { query: term },
    });













??????QUESTION?????? create a function component called ImageList which will receive the images from App component. render these images on the screen to make sure it worked well
??????QUESTION?????? make sure you have no errors or warnings in your console
??????QUESTION?????? use destructuring when mapping the images list for cleaner code













////        RENDERING THE IMAGES ON THE SCREEN   /////


create a functional component called ImageList with random text and import it to the App component and show it on the app


we will then pass the list of images from the App component to the ImageList component i.e. parent to child which we do using props
~ < ImageList images={this.state.images} />

we will then use a map to loop through all the images and print them

    const images = props.images.map(
        image => <img src={image.urls.regular} />
    )

    return (
        <div>
            {images}
        </div>
    )


this will now work, however it will throw a warning in the console that each child in a list should have a unique "key" prop


this is because when react is trying to render an item in a list, it will look for it in the dom. looking for it means it will check all the existing items in the dom if it exists so that it can update or not


having each item in a list containing a key means react will be able to look for the items more quickly and it improves the performance


we will then add the key/ id in the root tag of every item in our list i.e. the highest level element in our list


we happen to get ids from our results from unsplash at images.id

we'll also add description from the images to get rid of the alt warning

~ return <img alt={image.description} key={image.id} src={image.urls.regular} />


you can further simplify the code by destructuring from the map to reduce code repetition

const ImageList = (props) => {
    const images = props.images.map(({description, id, urls}) =>
    {
        return <img alt={description} key={id} src={urls.regular}/>
    }
)

























??????QUESTION?????? create ImageList.css in the components folder and import it in the ImageList component
??????QUESTION?????? give the root of the ImageList component a class name of image-list and add the following css
.image-list{
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
    grid-gap: 10px;
}

.image-list img {
    width: 250px;
}
??????QUESTION?????? create a new component called ImageCard and use it to print the image instead of the image tag in the ImageList component
??????QUESTION?????? what is a grid-auto-row and grid-row-end. explain how we can use this to reduce the white vertical space and why this using css only may not be enough to fix the white vertical space




















////        STYLING THE IMAGES      /////


we will use the grid css system

in the components' folder create a file called ImageList.css and import it in the ImageList component


add a class image-list to the root of our component

.image-list{
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
    grid-gap: 10px;
}

.image-list img {
    width: 250px;
}



grid-template-columns creates a set number of columns

auto-fill will decide how many columns to insert

minmax(250px, 1fr) means each column will be at minimum 250px wide and the maximum allocation of space wide


we're going to try and fix the vertical white spaces between the images

we can use grid-auto-rows to specify the height of an image and grid-row-end with span to specify how many grid spaces the image will occupy


however, this is difficult to do with css as all the images have varying heights


we will use react for this as we'll need to calculate the height of very image and based on this height determine the number of spans to be allocated


create a new react class component called ImageCard which will be responsible for rendering one image at a time


it will figure out the height of the image and based on this determine the grid-row-end span to accomodate for the size


class ImageCard extends React.Component{
    render() {
        const {description, urls} = this.props.image
        return (
            <div>
                <img alt={description} src={urls.regular} />
            </div>
        );
    }
}


also modify the images map now that we'll be passing our attributes and src to our component


note that we still have to pass the key however and we can not pass it to the component ImageCard

    const images = props.images.map((image) =>
        {
            return <ImageCard key={image.id} image={image}/>
        }
    )
















??????QUESTION?????? create a react ref for the image and console log the height of each image. (HINT!! listen for load and the height is contained in ClientHeight)

















we will now use our ImageCard component to dynamically calculate the size of an image in the following steps
- we will let the ImageCard render itself and its image
- reach into the DOM and figure out the height of the image
- set the image height on state to get the component to rerender
- when rerendering, assign grid-row-end to make sure the image takes up the appropriate space



in vanilla js we can access the dom using document.querySelector etc


in react this is different and we use the ref system instead


it gives you access to a single dom element


we create refs in the constructor, assign them to instance variables, then pass to a particular JSX element as props


we don't necessarily have to store them in state cause their values won't change


in ImageCard class add the following code

constructor(props){
    super(props);

    this.imageRef = React.createRef();
}

then pass it as a ref in the render function image element

<img ref={this.imageRef} alt{description} src={urls.regular} />


now anywhere inside this component, we can reference this.imageRef and it will tell us about the img element


we will access this in the componentDidMount method where we will first wait for it to load and for now we'll just console log the heights


    componentDidMount() {
        this.imageRef.current.addEventListener('load', this.setSpans)
    }

    setSpans = () => {
        console.log(this.imageRef.current.clientHeight)
    }














??????QUESTION?????? with this height, use grid-auto-rows and grid-row-end to get rid of the vertical white space between the images












with this height, we can now calculate the number of spans that will be needed for each image


first add a grid-auto-row: 10px at image-list
this means each grid container will have a height of 10px


with smaller rows, this means the whitespaces will be smaller and more accurate


we'll then dynamically set the grid-row-end with a span of the number of grid containers it will need to cover its height comfortably

ImageCard.js

import React from 'react'

class ImageCard extends React.Component{
    constructor(props) {
        super(props);

        this.state = ({spans: 0})

        this.imageRef = React.createRef()
    }

    componentDidMount() {
        this.imageRef.current.addEventListener('load', this.setSpans)
    }

    setSpans = () => {
        const height = this.imageRef.current.clientHeight

        const spans = Math.ceil(height/ 10)

        this.setState({spans})
    }

    render() {
        const {description, urls} = this.props.image
        return (
            <div style={{gridRowEnd: `span ${this.state.spans}`}}>
                <img ref={this.imageRef} alt={description} src={urls.regular} />
            </div>
        );
    }
}

export default ImageCard



ImageList.css

.image-list{
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
    grid-gap: 0 10px;
}

.image-list img {
    width: 250px;
}






















??????QUESTION?????? create a new react app called videos
??????QUESTION?????? do all the necessary set up and print Video App from the app component (class)
??????QUESTION?????? wire up semantic ui and add a container to the App component using the following semantic ui class "ui container"
??????QUESTION?????? create a SearchBar component (class) and console log the search term in the App component using necessary styling from semantic ui shown  below
    <div className="search-bar ui segment">
            <form className="ui form">
                <div className="field">
                    <label>
                        Search Video
                    </label>
                    <div className="ui icon input">
                        <input type="text" />
                    </div>
                </div>
            </form>
    </div>












we're going to create a new app which is going to be a youtube mock up


this app is going to need several components
1. SearchBar
2. VideoDetail
3. VideoList
4. VideoItem




create a new react app called videos


do all the necessary set up and print Video App from the app component


we will first start with the SearchBar


create the search bar and console log the search term in the App component















??????QUESTION?????? create an api folder in src, create a youtube.js file and store this api key 'AIzaSyBAlbEkd8ZAhrmR3whfpo0TwEsSJ3Sc9a8' in a variable called KEY
??????QUESTION?????? install axios and set up a preconfigured instance of it in the youtube.js file an import it to the App component
export default axios.create({
    baseURL: 'https://www.googleapis.com/youtube/v3',
    params: {
        key: KEY,
        part: 'snippet',
        maxResults: 5
    }
})
??????QUESTION?????? fetch a list of videos based on the search term from the youtube api and console log them to make sure it works. console log only the relevant data
        const response = await youtube.get('/search', {
            params: {
                q: term
            }
        })
??????QUESTION?????? print below the search input Found: x videos with x being the number of videos returned from the search






















we're now going to wire the youtube api to our project


go to google developers console and create a project in order to get an api key

create an api folder in src and create a youtube.js file

store the api key in this file


install axios and set up a preconfigured instance of it in the youtube.js file

import axios from "axios";

const KEY = 'AIzaSyBAlbEkd8ZAhrmR3whfpo0TwEsSJ3Sc9a8';

export default axios.create({
    baseURL: 'https://www.googleapis.com/youtube/v3',
    params: {
        key: KEY,
        part: 'snippet',
        maxResults: 5
    }
})


import this axios request and call it youtube

use it to fetch the data from youtube and set them as state in our App component to enable it to rerender


we will default it to an empty array too


    state = { videos: [] }

    onTermSubmit = async (term) => {
        const response = await youtube.get('/search', {
            params: {
                q: term
            }
        })

        this.setState({videos: response.data.items})
    }


    inside the render function

    Found: {this.state.videos.length} videos











??????QUESTION?????? set up the VideoList and VideoItem components to print out the thumbnail and title of each video
??????QUESTION?????? give our VideoList root component a class name of 'ui relaxed divided list'
??????QUESTION?????? use the following structure for the VideoItem
<div className="video-item item">
    <img className="ui image" />
    <div className="content">
        <div className="header"> Title </div>
    </div>
</div>
??????QUESTION?????? inside the components' directory, create a VideoItem.css, add the css below and import it to VideoItem.js

.video-item {
    display: flex !important;
    align-items: center !important;
    cursor: pointer;
}

.video-item.item img {
    max-width: 180px
}

















we will now render the list of the videos on the right hand side of our page


we'll create two separate components, the VideoList and VideoItem


set up the VideoList and VideoItem components to print out the thumbnail and title of each video


give our VideoList root component a class name of 'ui relaxed divided list' and each VideoItem a root class name of item


check the questions above to complete the full styling












??????QUESTION?????? console log the video a user clicks on the App component
??????QUESTION?????? create a piece of state in App that will be used to store the selected video














we will now look at how to open a detailed section of a video when a user clicks it


we'll add a new property on our state called selectedVideo and default it to null
state = { videos: [], selectedVideo: null }


when a user clicks on a video, we will update this to our state and pass it to a VideoDetail component


we will pass a callback function called onVideoSelect from the App to VideoList
    onVideoSelect = (video) => {
        console.log( 'From the App component', video)
    }

inside render function
    <VideoList onVideoSelect={this.onVideoSelect} videos={this.state.videos}/>



VideoList will then pass this callback to each VideoItem
    return <VideoItem onVideoSelect={onVideoSelect} key={video.id.videoId} video={video.snippet}/> //func comp
    or
    return <VideoItem key={video.id.videoId} video={video} onVideoSelect={this.props.onVideoSelect} /> //class comp


when a user clicks on a video, we will call the onVideoSelect function on the VideoItem and pass in the video clicked
    <div onClick={() => onVideoSelect(video) } className="video-item item">



this will invoke the onVideoSelect function which originates from the App and it will update its state












??????QUESTION?????? create a VideoDetail component which will print out on the screen the title of the video selected or print loading in case no video is clicked yet
??????QUESTION?????? use the following styles for the video title and description in VideoDetail
    <div className="ui segment">
        <h4>Title</h4>
        <p>Description</p>
    </div>














we will now create the VideoDetail component and pass it the selected video


first we will update our state selectedVideo property with the selected video
    onVideoSelect = (video) => {
        this.setState({selectedVideo: video})
    }

now create a new component called VideoDetail which will show a video player and the video title and description underneath it


for now we will just print the video title
const VideoDetail = ({video}) => {
    if (!video){
        return <div>Loading...</div>
    }

    return <div>{video.title}</div>
}


we will then import this to the App component and call it between SearchBar and VideoList passing the selected video as a prop
    <VideoList onVideoSelect={this.onVideoSelect} videos={this.state.videos}/>


we will now display a styled video title with the description
    <div className="ui segment">
        <h4>{video.title}</h4>
        <p>{video.description}</p>
    </div>
















??????QUESTION?????? display a video player for the video selected using the styles below
    <div>
        <div className="ui embed">
            Video Player
        </div>
        <div className="ui segment">
            <h4>Title</h4>
            <p>Description</p>
        </div>
    </div>
??????QUESTION?????? use the following styles in App to display VideoDetail on the left and VideoList on the right
    <div className="ui container">
        <SearchBar />
        <div className="ui grid">
            <div className="ui row">
                <div className="eleven wide column">
                    <VideoDetail />
                </div>
                <div className="five wide column">
                    <VideoList />
                </div>
            </div>
        </div>
    </div>
??????QUESTION?????? automatically select the first video of the search term
??????QUESTION?????? give a default search term whose videos will be displayed instead of the loading text












we're now going to display the video player using an iframe which can attempt to make an outside request which will be youtube in this case which will reply with the necessary html, css and js to show the video player

    <div>
        <div className="ui embed">
            <iframe src={videoSrc} />
        </div>
        <div className="ui segment">
            <h4>{video.snippet.title}</h4>
            <p>{video.snippet.description}</p>
        </div>
    </div>


with videoSrc being
    const videoSrc = `https://www.youtube.com/embed/${video.id.videoId}`




we will then use semantic ui's grid system to make VideoDetail show on the left side and VideoList on the right

    <div className="ui container">
        <SearchBar termSubmit={this.onTermSubmit} />
        <div className="ui grid">
            <div className="ui row">
                <div className="eleven wide column">
                    <VideoDetail video={this.state.selectedVideo} />
                </div>
                <div className="five wide column">
                    <VideoList onVideoSelect={this.onVideoSelect} videos={this.state.videos}/>
                </div>
            </div>
        </div>
    </div>


the app is now looking good with only one thing left. when a user first visits our app it shows the loading text as no input has been received from the user


we will use a default search term


one other issue is that when a user searches again, it still shows video details of the previously selected video


when a user searches for a video, we will pick one of the videos to be the selected video
    this.setState({
        videos: response.data.items,
        selectedVideo: response.data.items[0]
    })



for the default search term, we will define a componentDidMount life cycle method an manually call onTermSubmit function in App

    componentDidMount() {
        this.onTermSubmit('kenya')
    }


















??????QUESTION?????? what are hooks? give 3 examples of hooks and their use
??????QUESTION?????? initialize a new react app called widgets, create an functional App component and print Widgets App on the screen
??????QUESTION?????? in App, create an items array and hard code an array of objects which contain a title and content property
const items = [
    {
        title: 'Question 1',
        content: 'Answer 1'
    },
    {
        title: 'Question 2',
        content: 'Answer 2'
    },
    {
        title: 'Question 3',
        content: 'Answer 3'
    }
]
??????QUESTION?????? create an Accordion component which will receive this items element and print out the number of items in the array


















/////       THE HOOKS SYSTEM            ///


the hooks system is basically a way of giving functional components more functionality e.g

useState - a function that lets you use state in a functional component

useEffect - a function that lets you use something like lifecycle methods in a functional component

useRef - a function that lets you create a ref in a functional component


hooks are also a way to write reusable code instead of more classic techniques like inheritance


hooks give you a set of functions e.g. useState and on top of that you can create your custom hooks which will be doing one repeatable task


you can also use the set of predefined functions in your custom hook


we will be building a Widget application that will include multiple components. These components will be:
- An Accordion component
- A Wikipedia API search component
- A Dropdown item selection component
- A Google Translate API component

We will then wrap up the Widgets application by building our own navigation using JS and React without a third-party library like React Router. This will be used to navigate between the different widget components that were built.


initialize a new react app called widgets
~ create-react-app widgets


we will create an Accordion component and show it in the App component


create an array of items which we will pass down to it as props


we will hard code this items array in our App and every element in that array will be an object with a title and content properties


we will then communicate this to Accordion as props


you can create this array anywhere in the App, it looks better when done after the import statements

const items = [
    {
        title: 'Question 1',
        content: 'Answer 1'
    },
    {
        title: 'Question 2',
        content: 'Answer 2'
    },
    {
        title: 'Question 3',
        content: 'Answer 3'
    }
]


for now we'll just print the number of items in the list












??????QUESTION?????? wire up semantic ui to the project
??????QUESTION?????? give the root of Accordion the following style
<div className="ui styled accordion">
??????QUESTION?????? render the list of items using map and the following styles
     <React.Fragment key>
         <div className="title active">
             <i className="dropdown icon" />
             Title
         </div>
         <div className="content active">
             <p>Content</p>
         </div>
     </React.Fragment>
??????QUESTION?????? what is a React.Fragment and why do we use it in this case
??????QUESTION?????? create a function called onTitleClick which console logs the index of the element clicked. call this function when a user clicks the title of the accordion











React.Fragment is kind of a react tag that we use when we don't want to use an extra html tag


in this case we don't want to use a div cause semantic ui will kind of treat that as another accordion and it will have a double border at the top. in order to avoid that instead of using a div wrapper will, we will use React.Fragment


the styling looks good and the next thing we need to do is how to detect when a user clicks one of the titles


when a title is clicked, we will console log title clicked with the index


note that a map function allows us to pass the index of the element as a second argument and we will log this

  const renderedItems = items.map(
      (item, index) => {
         return(
             <React.Fragment key={item.title}>
                 <div className="title active" onClick={() => onTitleClick(index)}>
                     <i className="dropdown icon" />
                     {item.title}
                 </div>

....

    const onTitleClick = (index) => {
        console.log(`Title ${index} was clicked`)
    }















??????QUESTION?????? using hooks, print out the index of the element clicked after the accordion



















we're now going to make use of the hooks system in react


to learn this we will attempt to print out the index of the element clicked below the accordion


for a class based component we would simply
1. initialize a state with a property activeIndex
2. we will setState with the index when a user clicks a title
3. below the accordion we will print the value of the activeIndex from the state


for hooks its a little bit different


first we will import the useState function from react
import React, {useState} from 'react'


this is how we would initialize the state
const [activeIndex, setActiveIndex] = useState(null)

whenever we call useState, we get an array with two elements. the first element is our state item which will change over time while the second element is a function that we can use to update the value of the first element and just like setState it will cause our component to automatically rerender

whenever we call useState, it takes in one argument which is going to be the default value of our piece of state


this is how we would setState
setActiveIndex(index)


and this is how we would print the index of the element clicked below the accordion
<h1>{activeIndex}</h1>











??????QUESTION?????? remove the print out of the activeIndex
??????QUESTION?????? set up the collapsing and expanding of the clicked accordion. the accordion opens when you put the active class in the title and content, its absence means it will close










we will now look at expanding and collapsing the accordions


the expanding happens because of the active class in the title and content


in order to make it dynamic, while rendering our items, inside the renderedItems map we will compare the index with the activeIndex and save it in a variable, if they are the same we will give it a class of active and if they aren't the same it wont have the class active which will make it collapse


const active = index === activeIndex ? 'active' : ''


we will then join this with the class name for title and content

className={`title ${active}`}

className={`content ${active}`}


we can now also remove the print out of the activeIndex












??????QUESTION?????? delete the jsx for the Accordion in App. we will now be creating a search widget
??????QUESTION?????? create a search a function component called Search with the styling below and wire it to anticipate changes using state
      <div>
          <div className="ui form">
              <div className="field">
                  <label htmlFor="search">Enter Search Term</label>
                  <input type="text" className="input"/>
              </div>
          </div>
      </div>











we just finished building one widget and we'll move on to the next


we're going to create a search widget which is going to make use of the useState and useEffect hooks


its going to have a search input where a user can type in some topic. we will take this term and search the wikipedia api and return the results


we will be printing out the title and the snippet of the search term


we will also keep it simple unlike the youtube clone and have only two components, the App component and the Search component


the Search component will have two pieces of state, the term and results


delete the jsx for Accordion in App


create a new Search component and give it the classes below

      <div>
          <div className="ui form">
              <div className="field">
                  <label htmlFor="search">Enter Search Term</label>
                  <input type="text" className="input"/>
              </div>
          </div>
      </div>



the logic for the Search component is going to be the same as the youtube one before with the only difference being we're using a functional component now


we will initialize term in our state using useState

const [term, setTerm] = useState('')

then wire our input with state

    <input type="text" className="input" value={term}
           onChange={(event) => setTerm(event.target.value)}
   />














??????QUESTION?????? what is useEffect and how is it used














we will now take the search term to the wikipedia api


when a user updates the term, our component will rerender. we will then add code to detect that term has changed using the useEffect hook


the useEffect hook allows function components to use something like lifecycle methods


we configure the hook to run some code automatically in one of three scenarios
1. when the component is rendered for the first time only
2. when the component is rendered for the first time and whenever it rerenders
3. when the component is rendered for the first time and whenever it rerenders and some piece of data has changed


we will first import useEffect the same way we import useState


to make use of useEffect, we will call it and provide a function as the first argument


we will then configure it and tell it when we want it to be executed based on the 3 scenarios above


this is provided as the second argument in useEffect. this is going to be
1. an empty array, at initial render (scenario 1)
2. no array at all, at initial render and after every rerender (scenario 2)
3. an array with some value inside of it, run at initial render, run after every rerender if some element inside the array we passed has changed since last render (scenario 3). this array can have more than one element and useEffect is going to run if either of those elements change













??????QUESTION?????? make a search request to wikipedia api using the search term the user inputs. console log this response
use the link below to configure your request
https://en.wikipedia.org/w/api.php?action=query&list=search&origin=*&format=json&srsearch=cats




















we're now going to use scenario 3 and when the value of term changes, will make a request to wikipedia api


to make the request we will need to install axios


unfortunately we can't use the normal async await syntax with useEffect


there are three alternatives that we can use


1. inside use effect, create another async await helper function an call it in useEffect

const search = async () => {
    await axios.get('')
}

search()

this method is what is recommended

2. similar to the function but instead of creating a variable for the function, we create a self invoking function

(async () => {
    await axios.get('')
})();

3. use normal promises with .then

axios.get('').then( (response) => {
    console.log(response)
})


    useEffect(() => {
        const search = async () => {
          const response = await axios.get('https://en.wikipedia.org/w/api.php', {
              params: {
                  action: 'query',
                  list: 'search',
                  origin: '*',
                  format: 'json',
                  srsearch: term
              }
          })

          console.log(response)
        }

        search()
    }, [term])














??????QUESTION?????? save the array of results from the response to a new piece of state called results and console log its value. what are the two ways we can use to overcome the error in our results array due to the fact that our search term is an empty string by default
















we will create a new piece of state called results with it set method setResults with the default value as an empty array

const [results, setResults] = useState([])


we will then setResults to the data.query.search we receive from our request

setResults(response.data.query.search)


if we try and console log the value of results, we will get an error because our initial value of term is an empty string and the wikipedia api doesn't allow a search for an empty string


one solution for this is to set a default word as the value for term


another alternative is before running the search function, we will check if term has a value or not

        if (term) {
            search()
        }

an empty string is a falsy therefore the search function will not run

















??????QUESTION?????? use the classes below to style your list and find a workaround to remove the html tags in the code
    <div className="item">
        <div className="right floated content">
            <a
                className="ui button"
                href={`https://en.wikipedia.org?curid=${getThePageId}`}>
                Go
            </a>
        </div>
        <div className="content">
            <div className="header">
                Title
            </div>
            Summary
        </div>
    </div>
??????QUESTION?????? after the closing div of the ui form, add the following styles
        <div className="ui celled list">
            {renderedResults}
        </div>






















map through the results using the following styles

        <div key={result.pageid} className="item">
            <div className="right floated content">
                <a
                    className="ui button"
                    href={`https://en.wikipedia.org?curid=${result.pageid}`}>
                    Go
                </a>
            </div>
            <div className="content">
                <div className="header">
                    {result.title}
                </div>
                {result.snippet}
            </div>
        </div>



after the closing div of the ui form, add the following styles

        <div className="ui celled list">
            {renderedResults}
        </div>


this works but some html tags are displayed as text

    <span dangerouslySetInnerHTML={{__html: result.snippet}}/>




















??????QUESTION?????? throttle the search so that the search only happens after 1 second
(HINT use useEffect)
??????QUESTION?????? set a default search term as react. note that the throttle applies for this default search too. fix this bug



















we will now throttle our api requests to avoid a search on every input change


on input change, we will set a timer to search in 500ms, if another input change happens before this we will set another timer to search in 500ms

if 500ms expires without any input change we will execute the last timer


we can useState to monitor the timeout and cancel it if need be


however there is a much better way by using useEffect


the only thing we're allowed to return from a useEffect function is another function


the goal of that return function is to do some clean up


when the app first renders, the return function isn't automatically called

when the useEffect is run again, react will automatically return the return function from the previous run first then it will call the general function


    const timeoutId = setTimeout(() => {
        if (term) {
            search()
        }
    }, 1000)

    return() => {
        clearTimeout(timeoutId)
    }

 

unfortunately, this throttle still works for the default search if we hard coded our default search term. we will need to do an immediate search for the first run if we have a default word

    if (term && !results.length){
        search()
    } else {
        const timeoutId = setTimeout(() => {
            if (term) {
                search()
            }
        }, 1000)

        return() => {
            clearTimeout(timeoutId)
        }
    }














??????QUESTION?????? create a new component called Dropdown which prints dropdown, export it and import in App, delete the jsx for Search in App and use Dropdown instead
??????QUESTION?????? create an array of options which are objects containing label and value. pass it to Dropdown as prop. use the array that follows
const options = [
    {
        label: 'Red',
        value: 'red'
    },
    {
        label: 'Green',
        value: 'green'
    },
    {
        label: 'Blue',
        value: 'blue'
    }
]
??????QUESTION?????? map through the options array in Dropdown and use the following styles
  const renderedOptions = options.map(
      option => {
        return(
            <div key={option.value} className="item">
              {option.label}
            </div>
        )
      }
  )

??????QUESTION?????? style the jsx for the Dropdown as below
  <div className="ui form">
    <div className="field">
      <label htmlFor="dropdown" className="label" >
        Select a color
      </label>
      <div className="ui selection dropdown visible active">
        <i className="dropdown icon"/>
        <div className="text">Select color</div>
        <div className="menu visible transition">
          {renderedOptions}
        </div>
      </div>
    </div>
  </div>
??????QUESTION?????? create a piece of state called selected in App and pass it to Dropdown which is going to record what the current selection is. the default value should be the first item in our options array
??????QUESTION?????? also pass the setSelected function to dropdown























we're now going to move to our next widget, the dropdown widget which is going to make use of the useState, useEffect and useRef hooks


when the user clicks on the dropdown with some color selections. when a user selects a color it will update some text color immediately after it


we will have two components, App and Dropdown. Dropdown will receive props options of the dropdown menu from App


the options itself is going to be an array of objects with label and value
{
    label: 'Red or any random text',
    value: 'red'
}


we will also have a piece of state called selection which is going to record what the current selection is


this piece of state is going to exist in App and we will pass it as a prop to Dropdown


create a new component called Dropdown which prints dropdown, export it and import in App, delete the jsx for Search and use Dropdown instead


in App, create the options array and pass it to Dropdown as a prop

const options = [
    {
        label: 'Red',
        value: 'red'
    },
    {
        label: 'Green',
        value: 'green'
    },
    {
        label: 'Blue',
        value: 'blue'
    }
]




we will now work on our selection piece of state to keep track of what option is selected, we will also pass the selection setter as a prop


  const [selected, setSelected] = useState(options[0])


  <Dropdown
      selected={selected}
      onSelectedChange={setSelected}
      options={options}
  />


we will then wire these up in our Dropdown component


















??????QUESTION?????? in Dropdown component, replace the div which shows the Select color on the dropdown with the label in the selected state
??????QUESTION?????? when a user clicks on the items in the dropdown, replace the selected element
??????QUESTION?????? do not show the selected item on the dropdown menu
??????QUESTION?????? add the opening and closing functionality in our dropdown. by default it should be closed, when a user clicks on the dropdown it should open and when a user selects something it should close. the class 'visible active' and 'visible transition' is responsible for opening the dropdown. its absence closes the dropdown


















replace the div with select color text in our dropdown using the selected label

<div className="text">{selected.label}</div>


add an onClick function to our map which calls the setSelected function an causes a rerender
    <div
        key={option.value}
        className="item"
        onClick={() => onSelectedChange(option) }
    >
      {option.label}
    </div>


to improve the dropdown, we will not show the selected item on the dropdown menu

in the options map we will add this if statement before the return statement

    if (option.value === selected.value){
      return null
    }

null in react means don't render anything




the next thing is to add the opening and closing functionality in our dropdown


by default it should be closed, when a user clicks on it it should open and when a user selects something it should close

const [open, setOpen] = useState(false)

    <div className="ui form">
        <div className="field">
          <label htmlFor="dropdown" className="label" >
            Select a color
          </label>
          <div onClick={() => setOpen(!open) } className={`ui selection dropdown ${open ? 'visible active': ''}`}>
            <i className="dropdown icon"/>
            <div className="text">{selected.label}</div>
            <div className={`menu ${open ? 'visible transition' : ''}`}>
              {renderedOptions}
            </div>
          </div>
        </div>
  </div>















??????QUESTION?????? explain why the dropdown closes when we click on an item in our menu despite us not having code that say the dropdown should close when we click on an item in our menu
??????QUESTION?????? make the dropdown close when we click outside the dropdown while maintaining the current opening and closing functionality
??????BONUS QUESTION?????? add some text below the dropdown e.g this is red, the text should be written in the color of the item selected in the dropdown i.e this is red should be in red














we now want to close the dropdown when a user clicks outside the dropdown


the Dropdown can only easily listen an handle events from the elements it contains. in this case we're trying to listen for a click outside the Dropdown component


to do this we need to understand event bubbling in the dom


when a user clicks on something, the event objects contains the details on the click. the browser will then hand this event object to react which does some processing and provides the object to our onClick handler


the event object doesn't stop here, it goes to the parent element and checks if it has an onClick function. if it does it invokes it if it doesn't it goes to the parent of that element


this is what is called event bubbling


this is why when we click on an element in our menu, it bubbles up to the onClick function in its parent an closes up the dropdown menu


based on this, we will try to fix this problem this way. the Dropdown can set up a manual event listener (without react) on the body element. a click on any any element will bubble up to the body


we will use a useEffect hook in our Dropdown and whenever our component is rendered for the first time on the screen we can set up an event listener on the body element

  useEffect(() => {
    document.body.addEventListener("click",
        () => {
          setOpen(false);
        },
        { capture: true }
    );
  }, []);


the dropdown now closes when we click outside it but when we click on an item, it doesn't


this is because of the order of event bubbling and the order which onClick functions are called


body is called first, then item then dropdown


this is because the manual event listeners like the body are called first then the react event listeners


when we click on an item, body closes the dropdown but the onClick on dropdown reverses this, opens the dropdown again


to fix this, when a user clicks on a Dropdown element, we don't want the body listener to do anything.


when a user clicks on any element other than the Dropdown elements, we want the body listener to close the dropdown


we can figure out which element was clicked by checking event.target which gives us the dom element


in order to figure out if the element is a dropdown element, we will use useRef hook which will allow us to get a direct reference to a dom element. using this we will find the most parent element of the dropdown which is the ui form


import useRef

const ref = useRef();


we will then assign it to one of the elements that we are returning from the Dropdown component and in our case the most parent element which is the div ui form

<div ref={ref} className="ui form">


we can get a reference to that div by using ref.current


    useEffect(() => {
        document.body.addEventListener("click",
            (event) => {

                if (ref.current.contains(event.target)) {
                    return
                }
                setOpen(false);
            },
            {capture: true}
        );
    }, []);




















??????QUESTION?????? create a new component called Translate and import the Dropdown component
??????QUESTION?????? use the hard coded array of options in Translate
const options = [
    {
        label:'Spanish',
        value:'es'
    },
    {
        label:'Arabic',
        value:'ar'
    },
    {
        label:'Hindi',
        value:'hi'
    }
]
??????QUESTION?????? initialize state (language) and select the first option as the default option
??????QUESTION?????? pass in the necessary props required for Dropdown, pass the label for the dropdown as a prop "Select a language". (you may need to modify Dropdown in order to be able to support this label prop)
??????QUESTION?????? import this in App, delete the jsx for Dropdown and show translate instead
??????QUESTION?????? using the styles below, create a controlled input in Translate (above Dropdown) which will store the text that a user inputs
    <div className="ui form">
        <div className="field">
            <label htmlFor="input">Enter Text</label>
            <input type="text" />
        </div>
    </div>
























our last widget will be a translate widget where when a user inputs a text, they can select a language they want the text translated to which is displayed below


we will reuse our dropdown component here


our App will have 4 components, the App for general control, Translate which will be responsible for displaying the page, controlling the state and passing props and the Dropdown and Convert components


create a new component called Translate and import the Dropdown component


create a hard coded array of options

const options = [
    {
        label:'Afrikaans',
        value:'af'
    },
    {
        label:'Arabic',
        value:'ar'
    },
    {
        label:'Hindi',
        value:'hi'
    }
]


initialize state and select the first option as the default option

const [language, setLanguage] = useState(options[0])


the Translate component returns the Dropdown where we pass options as props. the Dropdown component also expects a selected and onSelected prop

    <div>
        <Dropdown
            selected={language}
            onSelectedChange={setLanguage}
            options={options}
        />
    </div>


import this in App, delete the jsx for Dropdown and show translate instead



we'll pass in a prop to customize the label that is shown on Dropdown instead of select a color

    label="Select a language"

    <label htmlFor="dropdown" className="label">
        {label}
    </label>



we'll create an input text which will track what the user inputs using a piece of state (text). this should be in Translate above Dropdown

const [text, setText] = useState('')

    <div className="ui form">
        <div className="field">
            <label htmlFor="input">Enter Text</label>
            <input type="text" value={text} onChange={event => setText(event.target.value)} />
        </div>
    </div>



































??????QUESTION?????? create a Convert component which will accept two props language and text which will be taken to the google translate api
??????QUESTION?????? set up google translate api using the axios request below to get the translated text stored at
response.data.data.translations[0].translatedText

const response = await axios.post('https://translation.googleapis.com/language/translate/v2', {}, {
                params: {
                    q: text,
                    target: language.value,
                    key: 'AIzaSyCHUCmpR7cT_yDFHC98CZJy2LTms-IwDlM'
                }
            })

??????QUESTION?????? Convert should return the styles below
       <div>
            <h1 className="ui header">
                translated text
            </h1>
       </div>

??????QUESTION?????? import Convert in Translate add the following styles
    <hr/>
    <h3 className="ui header">Output</h3>
    <Convert text={text} language={language} />





















ANSWER

import React, {useState, useEffect} from "react";
import axios from "axios";

const Convert = ({language, text}) => {

    const [translated, setTranslated] = useState('')

    useEffect(() => {
        const doTranslation = async () => {
            const response = await axios.post('https://translation.googleapis.com/language/translate/v2', {}, {
                params: {
                    q: text,
                    target: language.value,
                    key: 'AIzaSyCHUCmpR7cT_yDFHC98CZJy2LTms-IwDlM'
                }
            })

            setTranslated(response.data.data.translations[0].translatedText);
        }

        doTranslation()

    }, [language, text])


    return(
       <div>
            <h1 className="ui header">
                {translated}
            </h1>
       </div>
    )
}

export default Convert













??????QUESTION?????? debounce the axios request when a user changes the input to 500ms. use the 2 useEffect method to do this debouncing

















we now need to debounce/ throttle the axios request to 500ms

NOTE!!!  this method is similar to the debouncing in the wikipedia api component, however this uses two useEffect functions. the instructor was getting a 'React Hook useEffect has a missing dependancy' however i wasn't getting this warning (it seems there was an update on react which fixed this warning). this error is caused when you update a piece of state in useEffect which isn't listed in the array. both the method above and this below works for me without any warning


we will create two separate useEffect functions
1. - set a time to update debouncedText in 500ms
   - return a clean up function that cancels this timer

2. make a request with debouncedText


    const [translated, setTranslated] = useState('')
    const [debouncedText, setDebouncedText] = useState(text)

    useEffect(() => {
        const timerId = setTimeout( () => {
                setDebouncedText(text)
            }, 500)

        return () => {
            clearTimeout(timerId)
        }

    }, [text])

    useEffect(() => {

        const doTranslation = async () => {
            const response = await axios.post('https://translation.googleapis.com/language/translate/v2', {}, {
                params: {
                    q: debouncedText,
                    target: language.value,
                    key: 'AIzaSyCHUCmpR7cT_yDFHC98CZJy2LTms-IwDlM'
                }
            })

            setTranslated(response.data.data.translations[0].translatedText);
        }

        doTranslation()

    }, [language, debouncedText])




























??????QUESTION?????? using the route mapping below, set up routing from scratch for the widgets app component (NO REACT ROUTER)
localhost:3000/             -Accordion
localhost:3000/list         -Search
localhost:3000/dropdown     -Dropdown
localhost:3000/translate    -Translate
HINT!!! create a component Route linked to App which will decide on which component to render based on the pathname (you can check pathname using window.location.pathname)
??????QUESTION?????? create a Header component which will have the styles below and will be used to wire up the routing in App
<div className="ui secondary pointing menu">
    <a href="/" className="item">Accordion</a>
    <a href="/list" className="item">Search</a>
    <a href="/dropdown" className="item">Dropdown</a>
    <a href="/translate" className="item">Translate</a>
</div>


















we have will now work on the navigation for all the widgets which basically is showing different sets of components when the URL changes


to implement navigation, majority of react apps use React-Router


however it has frequent breaking changes

in this application we're going to build some navigation from scratch

it is also important to learn the ideas and theory of navigation


our route mapping will be
localhost:3000/             -Accordion
localhost:3000/list         -Search
localhost:3000/dropdown     -Dropdown
localhost:3000/translate    -Translate


the first thing will be how to determine the current url we're at. we will use window.location.pathname


we will create a component which will decide on which component to render based on the pathname


create a new component called Route which will receive a path and the component that we want to conditionally display


since we're not using any jsx, we don't have to import React

const Route = ({path, children}) => {
    return window.location.pathname === path ? children : null
}

export default Route


in App we will import Route and call it like below

    <Route path="/">
        <Accordion items={items} />
    </Route>


we will pass the Accordion in between the tags therefore it can be accessible as children

    <div>
        <Route path="/">
            <Accordion items={items} />
        </Route>
        <Route path="/list">
            <Search />
        </Route>
        <Route path="/dropdown">
            <Dropdown
                label="Select a color"
                options={options}
                selected={selected}
                onSelectedChange={setSelected}
            />
        </Route>
        <Route path="/translate">
            <Translate />
        </Route>
    </div>



we will now implement the header for our widgets


create a new component called Header which will have the styles below and import it in App

    <div className="ui secondary pointing menu">
        <a href="/" className="item">Accordion</a>
        <a href="/list" className="item">Search</a>
        <a href="/dropdown" className="item">Dropdown</a>
        <a href="/translate" className="item">Translate</a>
    </div>




















??????QUESTION?????? prevent a full page reload when a user clicks on an item on our Header
HINT!! create a new  component called a Link and import in Header which is going to display a link on the screen, a normal a tag
??????QUESTION?????? change the page url while still avoiding a full page reload using window.history.pushState({}, '', href)
















at the moment, when we click on another link, the whole page reloads and it reloads all the assets needed


this is not ideal for a react app where when a user clicks on a link, we will change the url but not do a full page refresh

each route can detect the url has changed

route will update piece of state tracking the current pathname

each route rerenders, showing/ hiding components appropriately


inside the Header component, we will create a new  component called a Link which is going to display a link on the screen, a normal a tag


we will add an onClick function which will execute a special logic when clicked


we will build a navigation event which is an object that will communicate to the rest of our application that the url has changed


when the other Routes receive this navigation event, it will take a look at the updated url and they will decide whether or not to display their respective child components


create a new component called Link which we will show instead of the current normal a tags and pass the respective content as props


we will then add an onClick function to our Link where we will add the special logic


the first thing will be to avoid a full page reload


const Link = ({className, href, children}) => {
    const onClick = (event) => {
        event.preventDefault()
    }

    return (
        <a
            onClick={onClick}
            className={className}
            href={href}
        >
            {children}
        </a>
    )
}


we will now think about how we can change the page url while still avoiding a full page reload


we will use a function that is built directly to the browser

window.history.pushState({}, '', href)





















??????QUESTION?????? now produce and emit a navigation event using the code below. this event will be used to tell all the routes that the url has changed
const navEvent = new PopStateEvent('popstate')
window.dispatchEvent(navEvent)
??????QUESTION?????? listen for this event in Route and console log 'the url has changed'
HINT!!! use useEffect which will contain an event listener and a clean up for the event listener
??????QUESTION?????? instead of a console log, render the appropriate child.
HINT!! you can cause a rerender by updating a piece of state























we will now produce and emit a navigation event so that we can tell all the routes that the url has changed and then they'll render appropriately

const navEvent = new PopStateEvent('popstate')
window.dispatchEvent(navEvent)


we will then add some code to Route to listen for this event


anytime we set up an eventListener in a functional component is a sign that we will need useEffect


we would want to wire this eventListener to start listening one time therefore we will pass an empty array as the second argument

window.addEventListener('popstate', onLocationChange)


we will also define this onLocationChange callback function right above

const onLocationChange = () => {
    console.log('Location change')
}



if we ever decide to stop showing this Route component, we will need to clean up this event listener therefore we will return a clean up function to stop listening


return () => {
    window.removeEventListener('popstate', onLocationChange)
}



instead of the console log location has changed, we will now tell the Component to rerender by creating a piece of state and updating it on the onLocationChange function


using the path, we will tell the Route whether to show its child or hide it


we will create a piece of state that tracks whatever the value of window.location.pathname is and cause a rerender

const [currentPath, setCurrentPath] = useState(window.location.pathname)


window.location.pathname and currentPath have the same value so technically the purpose of this piece of state is to cause a rerender


const onLocationChange = () => {
    setCurrentPath(window.location.pathname)
}



in our return jsx considering window.location.pathname is always up to date and has the same value, we can use that or currentPath state in our ternary operator

window.location.pathname === path ? children : null

or

currentPath === path ? children : null



there's one more subtle bug that we need to fix


normally in a browser when you hold the control key in windows or the command key in mac and click on a link, it should open in a new tab


this isn't working in our case cause we're preventing the normal behaviour of the browser

we will add this code at the top of our onLinkClick function in our Link component to do the normal browser behaviour in the case the control key or the command key is pressed

if (event.ctrlKey || event.metaKey){
    return ;
}













??????QUESTION?????? create a copy of the videos app and call it videos-hooks and start the server (it is easier to create a new folder, copy the files from videos minus node modules then npm i)
??????QUESTION?????? refactor SearchBar to a functional component
??????QUESTION?????? refactor App to a functional component
??????QUESTION?????? if you have an external onVideoSelect function in App, convert it to an inline function






















////            HOOKS PRACTICE          ////

in this section we're going to redo the youtube mock up app with hooks


in the file explorer, create a new copy of the videos app and call it videos-hooks


in that App we had 3 functional component, VideoList, VideoItem and VideoDetail, we're not going to do much on these


the App and SearchBar component are the class based components that we're going to refactor


start the project and begin to refactor on SearchBar


refactor the App component also


as we can see now, there is no change in performance and legibility, it is simply a change of syntax


to improve on legibility, we need to do some work on our end


replace the function below with an inline function
    const onVideoSelect = (video) => {
        setSelectedVideo(video)
    }


(video) => setSelectedVideo(video)

this can be further refactored to
setSelectedVideo














??????QUESTION?????? clean up App by creating a custom hook that contains all the video fetching logic
HINT!!! - create a custom hook called useVideos, (src/hooks/useVideos.js)
        - in App, identify all the code related to fetching the videos ONLY (in exception of jsx), identify the inputs needed, the outputs we get from that code and transfer it to useVideos
??????QUESTION?????? explain why you need to pass a defaultSearchTerm inside the useEffect in your hook
















at the moment, our video fetching logic is contained in the App component

we will create a custom hook which will contain video fetching logic

custom hooks is the best way to create reusable code in a react project besides components

they're created by extracting hook related code out of a function component

they always make use of at least one primitive hook internally

each custom hook should have one purpose

data fetching is a great thing to try and make reusable


these are the steps that we're going to use for creating reusable hooks


1. other than jsx, identify each line of code related to some single purpose
2. identify the inputs to that code
3. identify the outputs to that code
4. extract all of the code into a separate function, receiving the inputs as arguments and returning the outputs


for the video fetching logic, we will go through line by line identifying the purpose of each non jsx code in App and put all the code related to the video in a separate file


the inputs to these is the default search term and we get back (output) a list of videos with a function of performing our search operation


inside the src directory, create a new folder called hooks and create useVideos.js


it is a good practice to follow the convention of the primitive hooks e.g. in this case useVideos


we will import the useState and useEffect hooks and we will also need the axios we preconfigured to access youtube api


we will then define a useVideos function and export it at the bottom


import {useState, useEffect} from "react";
import youtube from "../api/youtube";

const useVideos = () => {

}

export default useVideos;


we will then take all the video related code and cut and paste to our useVideos hook


    const [videos, setVideos] = useState([])

    useEffect(() => {
        onTermSubmit('africa')
    }, [])


the onTermSubmit function contains a line related to selecting a video, this is not related to our hook, we will take the line setSelectedVideo(response.data.items[0]) out and we'll handle it later

    const onTermSubmit = async (term) => {
        const response = await youtube.get('/search', {
            params: {
                q: term
            }
        })

        setVideos(response.data.items)
    }



at the moment, a hard coded default search term works well but for reusability we need to provide a customizable default search term. this is what will be provided to our useVideos hook as an argument


with all inputs handled, we will now work on the outputs and make sure we return them in this case our list of videos and the onTermSubmit function which enables us to search for the videos


we can also see that the name of the function onTermSubmit isn't good in this context and we will replace it with search cause that's what it does


FINAL CODE

const useVideos = (defaultSearchTerm) => {
    const [videos, setVideos] = useState([])

    useEffect(() => {
        search(defaultSearchTerm)
    }, [])

    const search = async (term) => {
        const response = await youtube.get('/search', {
            params: {
                q: term
            }
        })

        setVideos(response.data.items)
    }

    return [videos, search]
}



we can now use useVideos in any component and as long as we provide a default search term, we will get back a list of videos and a function to search for the videos


we will import this in App, we're no longer using the youtube api so we can now delete it


we will then call useVideos just like any other hook

    const [videos, search] = useVideos('africa')


we will also need to update our jsx for our SearchBar and make sure anytime a user submits a new search,we should do a search of the youtube api like before. we can do this by calling the search function from useVideo after termSubmit

    <SearchBar termSubmit={search} />


this search function will update our videos piece of state in useVideos this will cause a rerender just the same as we had before


we will now go back to the selecting of the video, the one we removed from our search function and said we will get back to i.e anytime we get a new list of videos, we should select the first video automatically


immediately after we get back a list of videos, we should automatically select the first video from that list


we can do this by calling useEffect and passing videos as the second argument so anytime we get a new list of videos we will call setSelectedVideo and select the first video

    useEffect(() => {
        setSelectedVideo(videos[0])
    }, [videos])


there's one small warning that we will have to fix, react hook useEffect has a missing dependency: defaultSearchTerm


this is because we're using an outside variable defaultSearchTerm in useEffect and we're not passing it in the dependency array






















/////       DEPLOYMENT          ////


create react app contains a deployment bundle which requires a couple different files to run our project in the browser e.g index.html, index.css, bundle.js


these are static files that are used in the actual deployment where they'll be hosted


this is cheap and efficient compared to running something like a node server

















??????QUESTION?????? what is redux and why do we need it with react
??????QUESTION?????? explain the redux cycle and what happens at each stage, you can use the insurance company analogy for simplicity
??????QUESTION?????? create an action for the insurance company which creates a policy, we store the customers name and a certain amount of money for the creation of the policy
??????QUESTION?????? create a reducer of the create policy action
??????QUESTION?????? assuming you have redux wired up to the project, create a store, add 2 policies and console log the value of the store after the update




















/////           INTRO TO REDUX          /////


redux is a state management library which makes creating complex apps easier. rather than managing state in react components, we're going to extract it to redux


you can create applications with react alone but with redux it makes it even more easier especially in the case of a complex application


it is not required to create a react app and not explicitly designed to work with react


redux cycle
action creator -> action -> dispatch      -> reducers   -> state
customer       -> form   -> form receiver -> department -> compiled department data


action creator is a function that is going to create or return a plain js object which is referred to as an action


an action has a type property (some change we might want to make to our data) and payload property (some context on the change we want to make)

const createPolicy = (name, amount) => {
    return {
        type: 'CREATE_POLICY',
        payload: {
            name: name,
            amount: amount
        }
    }
}






the dispatch function is going to take in an action, make copies of that object and pass it to a bunch of different places in our application

dispatch is part of the redux library therefore we don't have to write it from scratch









a reducer is a function that is responsible for taking in some existing amount of data and an action passed in this order. it is going to process the action and make some change to the data then return it so that it can be stored in some centralized location

const createPolicy = (oldListOfPolicies = [], action){                  // oldListOfPolicies may be undefined at first run, in that case we initialize it to []
    if (action.type === 'CREATE_POLICY'){
        return [...oldListOfPolicies, action.payload]                   // spread the old array, add the new payload to create a new updated array
    }

    return oldListOfPolicies
}


const claimsHistory = (oldListOfClaims = [], action) => {
    if (action.type === 'CREATE_CLAIM'){
        return [...oldListOfClaims, action.payload]
    }

    return oldListOfClaims
}

we use return [...oldListOfClaims, action.payload] instead of push because all the time we want to change something in a reducer we create a new variable whether it is an array or an object etc

avoid updating existing data structures as much as possible

when our reducer is called for the first time, we might not have an old list of claims where its value will be undefined. we will need to default its value to an empty array oldListOfClaims = []











state is a central repository of all information that has been created by our reducers. it is centralized so that our application can reach in the redux side of our app and get access to all of the data instead of going to the individual reducers






so far, we haven't made even a single reference to the redux library and have only written js code


now that we have all our action creators and reducers, we will wire them together into a single object called a store


store in redux - an object which is an assembly of different reducers and action creators


we will need two functions from the redux library

const { createStore, combineReducers } = Redux


const ourDepartments = combineReducers({
    accounting: accounting,
    claimsHistory: claimsHistory,
    policies: policies
})

const store = createStore(ourDepartments)


this store represents our entire redux application. it contains references to all of our different reducers and all the data produced by the reducers


it also contains a couple of different functions that are going to be useful for what we want to do e.g the dispatch function


in order to test the full cycle, we will first create an action from our action creator

const action = createPolicy('Alex', 20)

store.dispatch(action)
this will forward this action to all the reducers in our application


store.getState()
this is a function that gets our entire assembled repository of data 


each line of dispatch is a separate execution of the redux cycle


running the dispatch function is the ONLY way we can modify our store

















??????QUESTION?????? create a new react redux app called songs hooked up with semantic ui that prints out songs
??????QUESTION?????? explain how react and redux integrate and how you would set up this songs app in this context















/// INTERGRATING REACT WITH REDUX


to test this, we will create a simple react app that can select a hard coded list of songs. selecting a song will print out the details of that song


~ create-react-app songs


we will divide our app into two, the left side will show the song list and the right side the song details


so far we've only used react and redux separately. in this app we will use both. we will install redux and a library called react-redux which will be used to integrate the two

~ cd songs

~ npm i redux react-redux


go to src and delete all files as usual

create index.js and write out the usual necessary boilerplate code and create an App functional component in a components folder which prints Songs


add semantic ui to our project as well



using react-redux we will create two components called Provider and Connect


we will pass some props to them to configure how they work


we will pass the store from redux as a prop into the Provider. the Provider is going to be rendered at the very top of our app hierarchy even above the App component


technically we're going to show the App inside the Provider


we will then find all the components that need to access data from our store. SongList definitely needs to access the list of songs produced by the reducer in our store


we will create an instance of the Connect component right above the SongList component. Connect communicates with the Provider (this is done directly using the context system which enables communication between parent and  child even if there are other components between them)


after the Connect component receives the list of songs from the Provider, it will pass it to SongList


we also have action creators as well. these are not stored in the store


we will pass some more configuration into Connect in addition to telling it we want to get the list of songs. we will tell it we want to call the select song action creator from within SongList


the action creator select song will be sent to SongList together with the list of songs from our store









??????QUESTION?????? set up your project structure for a react-redux application
??????QUESTION?????? create an action creator (receives song as an argument) for selecting a song and export it












this is how we're going to organize our project directory for a react redux application. inside src, we will have the following

/actions    - contains files related to action creators
/components
/reducers   - files related to reducers
index.js    - sets up both react and redux side of the app


inside the actions directory, create a file called index.js


we usually call the root file in actions and reducers as index so that they're the ones automatically called when we reference those directories


inside this index file, we will create an action creator called selectSong


a redux action MUST have a type, however a payload is optional

const selectSong = (song) => {
    return {
        type: 'SELECT_SONG',
        payload: song
    }
}


the next thing will be to export this action creator

upto this point, we've been exporting everything as export default


however, like in the example of this file, we will want to export multiple different functions (action creators)


we will therefore use a named export, to do that we will place the export keyword right in front of the function declaration

export const selectSong = (song) => {
    return {
        type: 'SONG_SELECTED',
        payload: song
    }
}


~ import { selectSong } from '../actions'















??????QUESTION?????? create two reducers in the appropriate file, one which returns a hard coded array of objects which contain the property title and duration and another reducer which selects a song
const songs =  [
              {title: 'No Scrubs', duration: '4.05'},
              {title: 'Macarena', duration: '2.30'},
              {title: 'All Star', duration: '3.15'},
              {title: 'I Want It That Way', duration: '1.45'}
          ]
??????QUESTION?????? finish setting up the reducers and export the necessary








we will then create an index.js file in reducers


we will have two reducers, on that will return a static hard coded list of songs and another one that is going to allow our users to select a specific song once they click the select button

const songsReducer = () => {
    return [
        {title: 'No Scrubs', duration: '4.05'},
        {title: 'Macarena', duration: '2.30'},
        {title: 'All Star', duration: '3.15'},
        {title: 'I Want It That Way', duration: '1.45'}
    ]
}

const selectedSongReducer = (selectedSong = null, action) => {
    if (action.type === 'SONG_SELECTED'){
        return action.payload
    }

    return selectedSong
}



we will then import combineReducers from redux in this file


~ import {combineReducers} from "redux"


export default combineReducers({
    songs: songsReducer,
    selectedSong: selectedSongReducer
})


we will export default combineReducers since it is the only file we will use externally



we're now done with the redux bit of our project and we will now focus on react and react-redux








??????QUESTION?????? configure the Provider tag/ component to our project












open index.js where we'll add more configuration to our project


our goal is to get the Provider component/ tag at the very top of our component hierarchy. we also need to make sure we pass it a reference to our redux store


we will import some files here. it is a good practice to separate external and internal imports

import React from "react";
import ReactDOM from "react-dom"
import {Provider} from "react-redux";
import {createStore} from "redux";

import App from "./components/App";
import reducers from "./reducers";


the next thing is to create an instance of our Provider and wrap our App in it while passing the redux store as a prop

ReactDOM.render(
    <Provider store={createStore(reducers)}>
        <App/>
    </Provider>
    , document.querySelector("#root"))














??????QUESTION?????? create a class based component called SongList which prints out SongList, wire this up with the App component
??????QUESTION?????? add the Connect component to SongList and use this to get the list of songs from the store within the SongList component. console log the list of songs inside SongList render function









we will now work on the react side and set up a SongList component and hooking it up to our App component


inside components, create class based SongList component with basic react mark up which prints out SongList

import React from "react";

class SongList extends React.Component {
    render() {
        return (
            <div>
                SongList
            </div>
        )
    }
}

export default SongList


we will then wire this to App

import React from "react";
import SongList from "./SongList";

const App = () => {
    return(
        <div>
            <SongList />
        </div>
    )
}

export default App



we will now start implementing the Connect component/ tag

import it at the top using the line below. note the lowercase c

import {connect} from "react-redux";


we will then call connect in our export default line.


connect is a function that returns a function. in this case it will pass SongList component as an argument to the returning function

export default connect()(SongList)


we're going to pass some configuration to our connect component. we will tell it that we want to get the list of songs from the redux store using the Provider


anytime the list of songs in our store changes, the Provider is going to notify connect also


connect is then going to pass the list of songs to our SongList component


to do this we're going to define a function which by convention is called a mapStateToProps which as the name suggest takes the state from the store and make is show up as props inside our component


this function is going to be called with all of the state from our redux store passed as an argument and is returned from this function as well

const mapStateToProps = (state) => {
    console.log(state)

    return state
}


this function is then passed as an argument in the first connect function

export default connect(mapStateToProps)(SongList)


running the code at this point will print out all the data in our store i.e selectedSong which is null at this point and the songs array


we now only want to pull of the songs array only and make sure that it gets into our SongList component as well


to do so, we will remove the console log in the mapStateToProps function and instead of returning the state, we will return an object


this object is going to have a key of songs whose value is going to be state.songs

const mapStateToProps = (state) => {
    return {songs: state.songs}
}


the object that we return from this function is going to show up as props inside our component
i.e this.props === {songs: state.songs}


console log this.props inside the render function. you will see the list of songs and we also get a dispatch function


we can use this dispatch function to update the data in our store, however there's a much convenient way to do that as we shall see ahead














??????QUESTION?????? print out the list of songs using the following styles

            <div className="item" >
                <div className="right floated content">
                    <button className="ui button primary">Select</button>
                </div>
                <div className="content">
                    //Song title
                </div>
            </div>

??????QUESTION?????? add the following styles to the render function
            <div className="ui divided list">
                // Song List
            </div>

??????QUESTION?????? add the following styles to the App component
        <div className="ui container grid">
            <div className="ui row">
                <div className="column eight wide">
                    <SongList />
                </div>
            </div>
        </div>











now that we have our list of songs, we can now start to focus on building a list of elements out of these songs usings maps showing the song title and a select button

    renderList(){
        return this.props.songs.map(
            song => {
                return(
                    <div className="item" key={song.title}>
                        <div className="right floated content">
                            <button className="ui button primary">Select</button>
                        </div>
                        <div className="content">{song.title}</div>
                    </div>
                )
            }
        )
    }



we will call this function in the render function and add some semantic ui classes as well

    <div className="ui divided list">
        {this.renderList()}
    </div>


we will then set up a grid system to pin the song list to the left and leave some space for the selected song details


we will add some classes to our App component

        <div className="ui container grid">
            <div className="ui row">
                <div className="column eight wide">
                    <SongList />
                </div>
            </div>
        </div>















??????QUESTION?????? wire up the select button which should update the redux store state. you can confirm that the selected song is updated by console logging the value of state in the mapStateToProps function









we will now work on selecting a song when a user clicks the select button


when the select button is clicked, we want to update the selectedSong in our redux store which can only be done by calling an action creator


the action creator will return an object action which will end up in the selectedSongReducer after it is dispatched


we can get access to the action creator selectSong which we had created earlier using the connect tag


we will import it from our actions file then wire it up to the connect tag

import {selectSong} from "../actions";


it is passed to the connect tag as a second argument of the first function as an object

export default connect(mapStateToProps, {
    selectSong: selectSong
})(SongList)


since the key and value have the same name we can shorten it to {selectSong}

export default connect(mapStateToProps, {selectSong })(SongList)


the connect function is going to take that selectSong action creator and pass it as a prop to SongList


if we call this selectSong function, it will take the action that gets returned and automatically send to redux dispatch function


we will set an onClick function on our button and call the selectSong function from our props

    <button onClick={() => this.props.selectSong(song)} className="ui button primary">Select</button>

we can confirm that the selected song is updating in our store by console logging the state in the mapStateToProps function which is run everytime the state is updated

const mapStateToProps = (state) => {
    console.log(state)
    return {songs: state.songs}
}


















??????QUESTION?????? create a functional component SongDetail which will be receiving the selected song from the redux store. console log the props of this function to confirm that it works after wiring it up to App using the styles below
    <div className="column eight wide">
        <SongList />
    </div>
    <div className="column eight wide">
        <SongDetail />
    </div>











we will now start working on the songDetail component which will be showing the title and duration for the selected song


inside components, create SongDetail.js which is going to be a functional component

we will console log the props to confirm that the selected song is received

import React from "react";
import {connect} from "react-redux";

const SongDetail = (props) => {
    console.log(props);
    return(
        <div>
            SongDetail
        </div>
    )
}

const mapStateToProps = (state) => {
    return {song: state.selectedSong}
}

export default connect(mapStateToProps)(SongDetail)




we will then import SongDetail to App with the following styles

        <div className="ui container grid">
            <div className="ui row">
                <div className="column eight wide">
                    <SongList />
                </div>
                <div className="column eight wide">
                    <SongDetail />
                </div>
            </div>
        </div>












??????QUESTION?????? print out the song details using the styles below
    <div>
        <h3>Details for:</h3>
        <p>
            Title: //title
            <br/>
            Duration: //duration
        </p>
    </div>









we will now print out the selected song details on the screen. in order to avoid referencing props all the time, we can destructure song from it in our SongDetail function


we also need to do some conditional rendering as at the first instance, the value of selected song is null

const SongDetail = ({song}) => {
    if (!song) return <div>Select a song</div>

    return(
        <div>
            <h3>Details for:</h3>
            <p>
                Title: {song.title}
                <br/>
                Duration: {song.duration}
            </p>
        </div>
    )
}















??????QUESTION?????? create a new react app called blog and install all the dependencies needed for a redux project including axios and redux-thunk
??????QUESTION?????? what is redux-thunk and what is it used for
??????QUESTION?????? delete all the files in src and put the necessary boilerplate code required for a react redux project. this should include a dummy reducer which shouldn't show any error on the console. App should contain the following style
    <div className="ui container">
        Blog
    </div>
??????QUESTION?????? wire up semantic ui
??????QUESTION?????? create a class based component PostList and import it in App














////////////////////
FETCHING DATA FROM AN API IN A REACT REDUX APP
////////////////////

in this app, we will
- understand the purpose of reducers
- making API requests with redux
- understand the purpose of middleware in this case redux-thunk


this app is going to display a list of blog posts that we're going to fetch from some API


we will have a component called PostList which is going to render a list of blog posts. it will also display the authors name from a component called UserHeader


we will fetch these blog posts from JSONPlaceholderAPI



create a new react app called blog


cd into blog and install all the dependencies we need for this project

~ npm i redux react-redux axios redux-thunk


redux-thunk is a middleware.


The term middleware applies to the redux library. middleware are functions which are going to slightly change the behaviour of our store by adding new features


in the case of redux-thunk, it is a middleware that is going to help use make network requests from the redux side of our app


delete all the files in src as usual and put necessary boiler plate for a react-redux application

src/index.js

import React from "react";
import {createRoot} from "react-dom/client";
import {Provider} from "react-redux";
import {createStore} from "redux";

import App from "./components/App";
import reducers from "./reducers";


const container = document.querySelector('#root')
const root = createRoot(container)
root.render(
    <Provider store={createStore(reducers)}>
        <App/>
    </Provider>)


App should just print blog with a semantic class "ui container"

    <div className="ui container">
        Blog
    </div>


we will now add a dummy reducer to get our app running

import {combineReducers} from "redux";

export default combineReducers({
    replaceMe: () => 'this is a dummy key value pair to start our project before we figure out the types of reducers we will need'
})



create a PostList component which will be a class based component and import it to App


we will also wire up semantic ui

















??????QUESTION?????? explain how data fetching is done in a react-redux app
??????QUESTION?????? create a dummy action called fetchPost which only returns the type for now
??????QUESTION?????? import this in PostList and for now we can just use null for our mapStateToProps function. call this function when the app is run for the first time. make sure you don't have any errors in your console











we will now look at how to fetch data in redux


the steps below are the steps followed for almost every time we fetch data in a redux application

1. Component gets rendered onto the screen
2. Components 'componentDidMount' lifecycle method gets called
3. we call action creator from 'componentDidMount'
4. action creator runs code to make API request
5. API responds with data
6. Action creator returns an action with the fetched data on the payload property
7. some reducer sees the action, returns data off the payload
8. because we generated some new state object, redux/ react-redux cause our react app to be rerendered



we will create a dummy action that we will import in PostList for now

export const fetchPosts = () => {
    return {
        type: 'FETCH_POSTS'
    }
}


to wire up this in PostList we will import the connect function

since we don't have the mapStateToProps function, we will just pass null as the first argument to the first function of our connect function

export default connect(null, {fetchPosts})(PostList)


we will then create the componentDidMount method and call our action creator from our props

    componentDidMount() {
        this.props.fetchPosts()
    }

















??????QUESTION?????? create a preconfigured instance of axios to JSONPlaceholder (https://jsonplaceholder.typicode.com)
??????QUESTION?????? use this pre configured instance of axios to make an API request to '/posts' and return the response as the payload to our action













our next step is to make our action creator make an API request


we will create a preconfigured instance of axios to JSONPlace holder. create a new folder called api and create jsonPlaceholder.js

import axios from "axios";

export default axios.create({
    baseURL: 'https://jsonplaceholder.typicode.com'
})


we will then import this in actions

one way that we can try and implement this is

import jsonPlaceholder from "../apis/jsonPlaceholder";

export const fetchPosts = async () => {
    const response = await jsonPlaceholder.get('/posts')

    return {
        type: 'FETCH_POSTS',
        payload: response.data
    }
}


this technically is correct js code but when we run it we get an error " Actions must be plain objects. Instead, the actual type was: 'Promise'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk'"


what's wrong with this?
- action creators must return plain js objects with type property (when converted to es5 code by create-react-app, it becomes different due to async await)
- by the time our action gets to a reducer, we won't have fetched our data as the request is async



in order to use an async action creator, you need to use a middleware like redux-thunk


this works by sending the dispatch function to our middlewares before going to the reducers


redux thunk is the middleware in this case


with redux thunk, action creators can return objects or functions which it will automatically call for you


redux thunk will check the item received, if it is an object it will send it to the reducers


if it is a function, it invokes it with dispatch and getState functions as arguments


it will then wait for the request to finish and when it's done we will dispatch action manually which will flow back to dispatch where it will be passed to redux thunk again


however this time we will have passed an object therefore it will be taken to the reducers


to wire up redux thunk as a middleware, we're going to go to our root index.js file and import it as well as applyMiddleware from redux

import {createStore, applyMiddleware} from "redux";
import thunk from "redux-thunk";


we declare the middleware in our Provider. for legibility, we will extract the create store function and define it as a variable.


we will call applyMiddleware with thunk as the argument as the second argument of our createStore function

const store = createStore(reducers, applyMiddleware(thunk))


<Provider store={store}>


we will go back to action index.js

export const fetchPosts = () => {
    return async (dispatch, getState) => {
        const response = await jsonPlaceholder.get('/posts')

        dispatch({type: 'FETCH_POSTS', payload: response.data})
    }
}


this can be further simplified to

export const fetchPosts = () => async dispatch => {
    const response = await jsonPlaceholder.get('/posts')

    dispatch({type: 'FETCH_POSTS', payload: response.data})
}














??????QUESTION?????? in the reducers folder, create a postsReducer.js which will handle the posts we have fetched
??????QUESTION?????? import this reducer in index.js and replace the replaceMe property













/////////////////////
REDUX STORE DESIGN
/////////////////////


we will now start working on our reducers


we will create a separate file for each reducer unlike last time where we put all reducers in reducers/index.js


this is a good design especially when it comes to scaling for large apps


our first reducer will be postsReducer which will be responsible for maintaining an array of all fetched posts


export default (state = [], action) => {
    if (action.type === 'FETCH_POSTS') return action.payload

    return state
}

however, in order to make sure we handle every action that comes to our reducer, we're going to use the switch statement instead of the if statement

the switch statement becomes handy when the reducer has so many cases it is checking for

export default (state = [], action) => {

    switch (action.type) {
        case 'FETCH_POSTS':
            return action.payload

        default:
            return state

    }
}



import in index and pass it in the combineReducers replacing the replaceMe property

import {combineReducers} from "redux";
import postReducer from "./postReducer";

export default combineReducers({
    posts: postReducer
})












??????QUESTION?????? what are the 4 rules of a reducer












rules of reducers
- must return any value besides undefined
- can only produce state using previous state and the action
- the only function must be to update the state using the previous state value and the action (reducers are pure)
- must not mutate its input 'state' argument which is easy when its data type is an object or an array. mutate is like updating contents of an array using an array method


the 4th rule is extremely misleading and possibly even false. this is because you can mutate the state and not get errors. it is easier to tell beginners not to mutate state than to tell them when they can or can't mutate state


an easier way is to say never update the state, return a new updated state as a new variable. check screenshots to see different ways you can return new variables while updating state (video 20/8)













??????QUESTION?????? wire up the mapStateToProps function and console log the list of posts we get from the API
??????QUESTION?????? print out each blog using the styles below
    <div className="item">
        <i className="large middle aligned icon user"/>
        <div className="content">
            <div className="description">
                <h2>//title</h2>
                <p>body</p>
            </div>
        </div>
    </div>
??????QUESTION?????? add the following styles in the render method

    <div className="ui relaxed divided list">
        //Post list
    </div>












we will now confirm if we get our list of posts in PostList by first configuring mapStateToProps


const mapStateToProps = (state) => {
    return {posts: state.posts}
}

export default connect(mapStateToProps, {fetchPosts})(PostList)


console log this.props inside the render function to confirm that we can receive the list of posts in our PostList component

    render() {
        console.log(this.props.posts);



we will then print out each blog using the styles below

    <div className="item" key={post.id}>
        <i className="large middle aligned icon user"/>
        <div className="content">
            <div className="description">
                <h2>{post.title}</h2>
                <p>{post.body}</p>
            </div>
        </div>
    </div>


and call this mappping function in the render method

    <div className="ui relaxed divided list">
        {this.renderList()}
    </div>
















??????QUESTION?????? what are the two ways that we can display the name of the blog author. (note you can access the details of the author by going to /users/1)
??????QUESTION?????? create a class based UserHeader component which for now will only print the text UserHeader.
??????QUESTION?????? we will create a separate fetch for each blog post to get the user. create an action creator which will fetch details of a specific user, the id of the user will be passed into UserHeader component as a prop from PostList.  wire up connect and the action creator created to UserHeader. you can use null as the mapStateToProps function for now
??????QUESTION?????? import UserHeader in PostList and call it right after the closing div of the h2 and p tag passing the userId as prop










we now want to display the user names for the blog post on each post


one way to do it is to fetch a list of all the posts and all the users. this can work however it is an unrealistic approach in the case where we have to fetch so many users and posts. fetching everything will definitely be a bottleneck


the right way to do this will be
- fetch posts
- show posts in PostList
- each element in PostList shows UserHeader
- UserHeader is given ID of user to show
- Each UserHeader attempts to fetch its user and show




we're going to create a new action creator called fetchUser and a usersReducer which is going to store a list of all the users

action

export const fetchUser = (id) => {
    return async (dispatch) => {
        const response = await jsonPlaceholder.get(`/users/${id}`);

        dispatch({type: 'FETCH_USER', payload: response.data})
    }
}


we should also note that this returns an object which contains details of the user



we will now start working on the UserHeader class based component, for now it should just display user header

we will import connect and fetchUser and wire it up. since we don't have a mapStateToProps function yet, we will just use null for now

class UserHeader extends React.Component{

    componentDidMount() {
        this.props.fetchUser(this.props.userId)
    }

    render() {
        return(
            <div>
                User Header
            </div>
        )
    }
}

export default connect(null, {fetchUser})(UserHeader)


import this in PostList and call it right after the closing div of the h2 and p tag passing the userId as prop

    <div className="content">
        <div className="description">
            <h2>{post.title}</h2>
            <p>{post.body}</p>
        </div>
        <UserHeader userId={post.userId} />
    </div>



















??????QUESTION?????? create a reducer that will store a list of all the fetched users and add it to combineReducers
define mapStateToProps in UserHeader and print out the name of the user on the screen using the style below
        <div className="header">
            //Name
        </div>
??????QUESTION?????? refactor the code and only pass the relevant user to the class instead of the array of all the users













we're now going to create a reducer that will use the action from fetchUser and store an array of all the users that we have fetched


create a file called usersReducer.js

export default (state = [], action) => {

    switch (action.type) {
        case 'FETCH_USER':
            return [...state, action.payload]

        default:
            return state
    }
}


we will then wire this to our combineReducers

export default combineReducers({
    posts: postsReducer,
    users: usersReducer
})


we will then define mapStateToProps in UserHeader and use find to get the user details. print out the name of the user on the screen


class UserHeader extends React.Component{

    componentDidMount() {
        this.props.fetchUser(this.props.userId)
    }

    render() {

        const user = this.props.users.find(user => user.id === this.props.userId)

        if (!user) return null

        return(
            <div className="header">
                {user.name}
            </div>
        )
    }
}

const mapStateToProps = (state) => {
    return {users: state.users}
}

export default connect(mapStateToProps, {fetchUser})(UserHeader)



we will do some refactor on UserHeader. it is a good practise especially for reusability purpose to put all the computations that we do on our redux state on the mapStateToProps function


we will remove the find statement from the class and instead of returning the whole list of users, only return the found user from our mapStateToProps function


we will see that we will need to access the props to get the id of the user from PostList. mapStateToProps can access a reference of the props of a component by passing ownProps as the second argument


we will then destruct this found user in our class from the props and the code will work like it used to

class UserHeader extends React.Component{

    componentDidMount() {
        this.props.fetchUser(this.props.userId)
    }

    render() {

        const {user} = this.props

        if (!user) return null

        return(
            <div className="header">
                {user.name}
            </div>
        )
    }
}

const mapStateToProps = (state, ownProps) => {
    return {user: state.users.find(user => user.id = ownProps.userId)}
}















??????QUESTION?????? note how we are fetching duplicate records of users as we run the fetchUser action creator in all the UserHeader components. solve this by using memoization (from lodash)









there is an issue with our code, we're doing a user request for each blog post which means we will be doing 100 request while we only have 10 users


we need to figure out a way of not making a duplicate request for each user and only fetch once for each user instead of 10 times


we can solve this in two ways


one way will be to use memoize function from lodash


memoize runs the request once. in case we repeat this request, it will not run the request again but instead only return the result of the similar request


we will install lodash

~ npm - lodash

we will then import loadash in our actions creator file

import _ from "lodash"


unfortunately, we can not memoize our fetchUser function directly due to redux rules and the configuration difference caused by redux-thunk


to correctly memoize once, we need to define a function outside our action creator that is going to actually make the request and dispatch the action. we're going to memoize it outside the action creator

export const fetchUser = (id) => {
    return (dispatch) => {
        _fetchUser(id, dispatch)
    }
}


const _fetchUser = _.memoize( async (id, dispatch) => {
    const response = await jsonPlaceholder.get(`/users/${id}`);

    dispatch({type: 'FETCH_USER', payload: response.data})
})


on side effect to this solution is that if you want to refetch a user in the case something about the user has updated for example, it won't be possible with this action creator


we will have to create another function that applies the action creator logic without the memoization bit
















??????QUESTION?????? solve the over fetching problem by finding all the unique user id's first from the list of posts and only running fetchUser over these unique ids













an alternative way to solve this is to call fetchPosts, find all unique userId's from the list of posts, iterate over unique userIds, call fetchUser with each userId


we will first undo the memoization and return the code to how it was before

export const fetchUser = (id) => {
    return async (dispatch) => {
        const response = await jsonPlaceholder.get(`/users/${id}`);

        dispatch({type: 'FETCH_USER', payload: response.data})
    }
}


we will create a new action creator called fetchPostsAndUsers and we will wire it up with redux-thunk like the others


in this function, we're going to call fetchPosts and fetchUser multiple times


we need to make sure when these other action creators are called, the get dispatched as well


we do this by passing the results of these functions into dispatch
    dispatch(fetchPosts())


because fetchPosts is async we need to put the await keyword before it to make sure we wait to get the results before we move on
    await dispatch(fetchPosts())


the second step will be now getting the fetched list of posts. we can get access to this by passing getState as the second argument in the return function in redux-thunk


we can log this to make sure it works

export const fetchPostsAndUsers = () => {
    return async (dispatch, getState) => {
        await dispatch(fetchPosts())

        console.log(getState().posts)
    }
}


wire this with PostList, replacing fetchPosts with fetchPostsAndUsers and run the code


the next thing will be to iterate through this list of posts, find unique user ids and then fetch a user for each one


to do this we're going to make use of the lodash library and do memoization


lodash is also going to make working with this list of posts, pulling out the user ids and finding the unique ones pretty easy and straight forward


first of we're going to use lodash's map to pull off just the unique user id. this will return an array of all the user ids

    _.map(getState().posts, 'userId')


we now need to go through this and find just the unique user ids which is going to return an array with just the unique user ids

    const userIds = _.uniq(_.map(getState().posts, 'userId'))


you can console log this to test if it works


the next this will be to iterate over this list of ids and for each id, call fetchUser

    userIds.forEach(id => dispatch(fetchUser(id)))

it is not a must to use await in this dispatch as we do not care about waiting for each user to be fetched and also because it is the last line of code in this function


also you can't use async await in a forEach loop


this is all set and now to make sure we don't get duplicate request, we're going to refactor UserHeader


we will remove the componentDidMount which was fetching data for each user, we can also remove the fetchUser code


we can do a little bit of an optional refactor to make our code even more compact using lodash


note that we're doing a map, unique and forEach over our list of users


to simplify this, we can use a special function in lodash called chain that allows us to chain on a bunch of additional functions that are going to manipulate some collection of data


for chain, the result of the previous action is automatically passed as the first argument i.e for map we will only pass 'userId' which will be the 2nd argument, for uniq we will not pass anything as the result for map will be passed automatically as the first argument


we need to pass .value as the last item on the chain which basically makes this execute

    _.chain(getState().posts)
        .map('userId')
        .uniq()
        .forEach(id => dispatch(fetchUser(id)))
        .value()



















??????QUESTION?????? create a new folder called streams. create a new react app called client in this folder
??????QUESTION?????? write the necessary biolerplate code for a react app only














/////////////////
NAVIGATION WITH REACT ROUTER
/////////////////


the next app we're going to do is a twitch clone

the streamer's computer is going to be running an Open Broadcaster Software (OBS)

this is going to stream the video to some outside server called Real Time Messaging Protocol (RTMP) which will broadcast the feed to a bunch of different users who can watch from their browsers

the RTMP is sole purpose is streaming videos but we also have some other information that we want to share with our users such as the other streams that are currently broadcasting. we will have another api which is going to be handling this

we're going to have 3 parts in our app:
1. our react application running in the users browser
2. a tiny api which is going to list out the streams available
3. RMTP for handling the video feeds



our application is going to have some authentication where a user can log in and out


when a user is not logged in they can only see the landing page which shows a list of streams available or view a stream


logging in gives the user added functionality of creating a stream, editing a stream they had created earlier or deleting it


our project directory is going to be a little bit different than the previous ones, instead of creating a react app directly, we're going to have some different sub project inside one directory. one for our react application, for the rtmp server and for the api server that lists the different streams that are available


create a new folder called streams and cd in. create a new react app called client



the challenges that we're going to face in this app include
- navigating to separate pages. we will use a library called react router
- logging in and logging out
- handling forms in redux
- mastering CRUD operations in React/ Redux
- errors will likely occur so we will need good error handling


cd into client, delete everything in src


at first we will not focus on redux, we will only render out a react app so that we can concentrate on routing and navigation


index.js

import React from "react";
import {createRoot} from "react-dom/client";

import App from "./components/App";

const root = createRoot(document.querySelector("#root"))

root.render(<App />)

App.js

import React from "react";

const App = () => {
    return(
        <div>
            Client
        </div>
    )
}

export default App














??????QUESTION?????? install react router to your project
??????QUESTION?????? configure react router with your project
??????QUESTION?????? create two functional components in App called PageOne and PageTwo which contain an a tag with a link to "/two" and "/" respectively
??????QUESTION?????? configure App to show PageOne at "/" and PageTwo at "two"














~ npm i react-router-dom


it is important not to forget the dom at the end i.e react-router-dom as react-router is a different library. it is the core navigation library that we don't install manually

open the src/index.js in your text editor. Import BrowserRouter from react-router-dom near the top of your file and wrap your app in a <BrowserRouter>

root.render(
    <BrowserRouter>
        <App />
    </BrowserRouter>
)

Now you can use React Router anywhere in your app

import { Routes, Route, Link } from "react-router-dom";


react router doesn't care about the hostname/ domain


BrowserRouter listens to browser history for changes to the URL

BroswerRouter will then communicate the path to the Route component which will decide whether to hide or show themselves based on the path that the user is visiting and the path property that it was passed when it was created

it then shows the respective Route when the path matches the current URL


we will create two functional components in App called PageOne and PageTwo which contain an a tag with a link to "/two" and "/" respectively

const PageOne = () => {
    return(
        <div>
            <a href="/two">Go to page two</a>
        </div>
    )
}

const PageTwo = () => {
    return(
        <div>
            <a href="/">Got to page one</a>
        </div>
    )
}

const App = () => {
    return(
        <div>
            <Routes>
                <Route path="/" element={<PageOne />} />
                <Route path="/two" element={<PageTwo />} />
            </Routes>
        </div>
    )
}












??????QUESTION?????? explain why using a tags for navigation in react isn't a good approach
??????QUESTION?????? fix using the correct approach












using a tags to set up navigation for react apps isn't a good approach


this is because clicking on an a tag makes the react development server respond with index.html file at all times (located in public folder)


the browser receive an index.file, this dumps the old html file it was showing previously (including all of our react redux state data)


this index.html file will list our js file in script tags, browser downloads and executes these scripts and our app starts up again afresh


this is the normal operation of a browser


to do this the react way, we will import Link component from react router

import {BrowserRouter, Route, Link} from "react-router-dom";


when we use the link tag, we replace href with to

<Link to="/two">Go to page two</Link>



what happens when a user clicks on the Link tag is
- React router prevents the browser from navigating to the new page
- the url still changes
- history (browser history object) sees updated url, takes updated url to BrowserRouter
- BrowserRouter communicates the url with Route components
- route components rerender to show new set of components










??????QUESTION?????? create the following components in our app, they should be functional components and add some boilerplate code to each
??????QUESTION?????? in App, delete the existing PageOne and PageTwo components, import the streams component and wire them up with the paths below
- StreamList        /
- StreamShow        /streams/show
- StreamCreate      /streams/new
- StreamEdit        /streams/edit
- StreamDelete      /streams/delete










we will now scaffold a bunch of different components and hook them to our react router instance with individual Route components so that we don't have to revisit routing


we will need the following components in our app
- StreamList        /
- StreamShow        /streams/show
- StreamCreate      /streams/new
- StreamEdit        /streams/edit
- StreamDelete      /streams/delete



for organization purposes, we will create these components in one folder components/streams


we will add some boilerplate code to each file

import React from "react";

const StreamList = () => {
    return(
        <div>
            StreamList
        </div>
    )
}

export default StreamList


in App, we will first delete the existing PageOne and PageTwo components, import the streams component and wire them up

import StreamList from "./streams/StreamList";
import StreamShow from "./streams/StreamShow";
import StreamCreate from "./streams/StreamCreate";
import StreamEdit from "./streams/StreamEdit";
import StreamDelete from "./streams/StreamDelete";


const App = () => {
    return(
        <div>
            <Routes>
                <Route path="/" element={<StreamList />} />
                <Route path="/streams/show" element={<StreamShow />} />
                <Route path="/streams/new" element={<StreamCreate />} />
                <Route path="/streams/edit" element={<StreamEdit />} />
                <Route path="/streams/delete" element={<StreamDelete />} />
            </Routes>
        </div>
    )
}











??????QUESTION?????? add semantic ui to the project
??????QUESTION?????? create a navbar which will show on all routes, use the following styles replacing a with link
    <div className="ui secondary pointing menu">
        <a href="/" className="item">Streamy</a>
        <div className="right menu">
            <a href="/" className="item">All streams</a>
        </div>
    </div>
??????QUESTION?????? add className ui container to the root div in App












we will now start working on the always visible components e.g the navbar which shows on all pages


to do this, we will add the Header component on the same level as BrowserRouter which will make it show irrespective of the path


we can test this by creating a h1 tag above BrowserRouter


the header should have a link to the home page and a login button


we will wire up semantic ui and create a Header component inside components directory.

        <div className="ui secondary pointing menu">
            <Link to="/" className="item">Streamy</Link>
            <div className="right menu">
                <Link to="/" className="item">All streams</Link>
            </div>
        </div>


add className ui container to the root div in App
















??????QUESTION?????? we're going to set up google OAuth. the steps below have already been done
- creating a new project at console.developers.google.com
- setting up an OAuth confirmation screen
- generating an OAuth client ID
??????QUESTION?????? install google api library in our project by adding a script tag in the head of index.html
<script src="https://apis.google.com/js/api.js"></script>
??????QUESTION?????? create a class based component called GoogleAuth. we will then import this inside Header and create an instance of it after to the Link to All Streams
??????QUESTION?????? which will wire up google api library using the code below when the component is run for the first time.
    window.gapi.load('client:auth2', () => {
        window.gapi.client.init({
            clientId: '56979298790-rkgajibrgamgou7f09g28pots22dojgl.apps.googleusercontent.com',
            scope: 'email',
            plugin_name: 'Streamy'
        }).then(()=> {
            this.auth = window.gapi.auth2.getAuthInstance()
        })
    })
??????QUESTION?????? create a piece of state called isSignedIn which we will be storing the authentication status for the user which we can get from this.auth.isSignedIn.get() (returns true if signed in and false if not). set the value of isSignedIn to the correct authentication status after wiring up google api library in GoogleAuth
??????QUESTION?????? create a function which updates the value of isSignedIn based on this.auth.isSignedIn.get(). call this function in this.auth.isSignedIn.listen() is an event listener that listens to changes to the authentication status
??????QUESTION?????? show a sign in or sign out button based on the authentication status with the following styles
        <button className="ui red google button">
            <i className="google icon" />
                Sign in/ Sign Out
        </button>
??????QUESTION?????? add event handlers to this button to sign in and out using google OAuth. this.auth.signIn() signs in and this.auth.signOut() signs out the user
















/////////////////////////
AUTHENTICATION
/////////////////////////


we will use authentication with google (OAuth2)


- the user authenticates with google
- user authorizes our app to access their information
- google tells us about the user
- we're trusting that google with correctly handle identification of a user
- OAuth can be used for:
        1) user identification in our app
        2) our app making actions on behalf of user



you can do OAuth for servers or OAuth for js browser apps


steps for setting up OAuth
- create a new project at console.developers.google.com
- set up an OAuth confirmation screen
- generate an OAuth client ID
- install google's API library, initialize it with the OAuth client ID
- make sure the lib gets called anytime the user clicks on the login with google button



to set up OAuth confirmation screen, go to OAuth consent screen and generate a new screen which basically is entering the application name, email and saving


we will then create credentials and select OAuth client id and use http://localhost:3000 as the authorized js origins. this will give us a client id back


we will then install google api library in our project by adding a script tag in the head of index.html

<script src="https://apis.google.com/js/api.js"></script>


we will now create a react component that will wrap this api and user our user through the entire OAuth process


inside components, create GoogleAuth.js and put some boilerplate for a class based component which for now only prints out GoogleAuth


we will then import this inside Header and create an instance of it next to the Link to All Streams


we want to load up the google api library only once when GoogleAuth is rendered on the screen

we will now render the authentication status

- get a reference to the auth object after it is initialized
- figure out if the user is currently signed in
- print the authentication status on the screen

    state = {isSignedIn: null}

    componentDidMount() {
        window.gapi.load('client:auth2', () => {
            window.gapi.client.init({
                clientId: '56979298790-rkgajibrgamgou7f09g28pots22dojgl.apps.googleusercontent.com',
                scope: 'email',
                plugin_name: 'Streamy'
            }).then(()=> {
                this.auth = window.gapi.auth2.getAuthInstance()
                this.setState({isSignedIn: this.auth.isSignedIn.get() })
                this.auth.isSignedIn.listen(this.onAuthChange)
            })
        })
    }

    onAuthChange = () => {
        this.setState({isSignedIn: this.auth.isSignedIn.get()})
    }

    renderAuthButton(){
        if (this.state.isSignedIn === null){
            return <div>I don't know if we are signed in </div>
        } else if (this.state.isSignedIn){
            return <div>I am signed in</div>
        } else {
            return <div>I am not signed in</div>
        }
    }

    render() {
        return(
            <div>
                {this.renderAuthButton()}
            </div>
        )
    }
}

we will now show a sign in or sign out button

    <button className="ui red google button">
        <i className="google icon" />
            Sign Out
    </button>

we will then add event handlers to these buttons to sign in/ out the users

    onSignOutClick = () => {
        this.auth.signIn()
    }

    onSignInClick = () => {
        this.auth.signIn()
    }

``
    <button onClick={this.onSignInClick} className="ui red google button">
















??????QUESTION?????? install redux to the project, set up the project structure for a redux project. create a dummy reducer and wire up the root index.js file with redux












our code is working well now but we have to restructure it to integrate redux


the state in GoogleAuth is the only place where we can know whether the user is signed in or not. using a redux store instead means that we can access the auth status from anywhere in our app


~ npm install redux react-redux


create actions and reducer folder and files

reducer/ index.js

import {combineReducers} from "redux";

export default combineReducers({
    replaceMe: () => 'To be replaced'
})


we will then wire up our root index.js file to redux


import React from "react";
import {createRoot} from "react-dom/client";
import {BrowserRouter} from "react-router-dom";
import {Provider} from "react-redux";
import {createStore} from "redux";

import App from "./components/App";
import reducers from "./reducers";

const root = createRoot(document.querySelector("#root"))
const store = createStore(reducers)

root.render(
    <BrowserRouter>
        <Provider store={store}>
            <App/>
        </Provider>
    </BrowserRouter>
)
















??????QUESTION?????? create a signIn and signOut action creators. we're assuming we will have a boolean flag in our reducer which will be inverted based on the type of the action
??????QUESTION?????? hook these action creators to GoogleAuth
(HINT this.auth.isSignedIn.listen() returns a boolean which is returned as an argument to this function)










we will now set up some action creators and wiring them up with our GoogleAuth component

open action/index


we will create two action creators which we will call once we have successfully logged in the user


export const signIn = () => {
    return {
        type: 'SIGN_IN'
    }
}

export const signOut = () => {
    return {
        type: 'SIGN_OUT'
    }
}


we will have a boolean flag in our reducer which will be inverting the value of auth status based on the type of the action


we will then hook up these actions to GoogleAuth

export default connect(null, {signIn, signOut})(GoogleAuth)


then once the user signs in or signs out, we will call the appropriate action creator


this.auth.isSignedIn.listen() returns a boolean which is returned as an argument to this function, we can use this to modify out onAuthChange function

    onAuthChange = (isSignedIn) => {
        if (isSignedIn) {
            this.props.signIn()
        } else {
            this.props.signOut()
        }
    }












??????QUESTION?????? create an authReducer which initial state should be an object it will contain two properties, isSignedIn an another one that we will add later
??????QUESTION?????? wire this with reducers index











create a new file in reducers called authReducer


we will default our state to an object because we will need to add another property to this later


however we still need to initialize the default value of isSigned in to null, we will therefore initialize it in a variable


const INITIAL_STATE = {
    isSignedIn: null
}

export default (state = INITIAL_STATE, action) => {
    switch (action.type) {
        case 'SIGN_IN':
            return {...state, isSignedIn: true}

        case 'SIGN_OUT':
            return {...state, isSignedIn: false}

        default:
            return state
    }
}



wire it with reducers index replacing the dummy reducer

import {combineReducers} from "redux";
import authReducer from "./authReducer";

export default combineReducers({
    auth: authReducer
})












??????QUESTION?????? wire up the buttons to enable signing in and signing out
??????QUESTION?????? use type system in your project to avoid mispelling types












we will now wire up our buttons to update the redux store using action creators

we will add a mapState to props

const mapStateToProps = (state) => {
    return {isSignedIn: state.auth.isSignedIn}
}

we no longer need Component level state, so we can refactor our code and remove it


remove state initialization

replace
    this.setState({isSignedIn: this.auth.isSignedIn.get() })

with
    this.onAuthChange(this.auth.isSignedIn.get())

update renderAuthButton to be checking
    this.props.isSignedIn === null)




we will now do a quick refactor to our action reducer and creators


one common mistake with redux is mistyping the type between action creators and reducers as the spelling needs to be exactly the same


inside actions folder, create a file called types

export const SIGN_IN = 'SIGN_IN'
export const SIGN_OUT = 'SIGN_OUT'

and import these in actions and reducer














??????QUESTION?????? we now need to associate the users with streams. each stream will have an id of the user who created it. we can get this from this.auth.currentUser.get().getId() in GoogleAuth. refactor GoogleAuth, actions and the authReducer to be able to handle userId when a user signs in













we now need to associate the users with streams. each stream will have an id of the user who created it


we can get these ids from google auth


to do this, we will pass the id from google as an argument to our action creator signIn

    this.props.signIn(this.auth.currentUser.get().getId())


in our action, we will then add this user id as a payload property

export const signIn = (userId) => {
    return {
        type: SIGN_IN,
        payload: userId
    }
}




we will now also update the authReducer so that when a user signs in, we pass the id as well

first initialize userId as null

const INITIAL_STATE = {
    isSignedIn: false,
    userId: null
}

export default (state = INITIAL_STATE, action) => {
    switch (action.type) {
        case SIGN_IN:
            return {...state, isSignedIn: true, userId: action.payload}

        case SIGN_OUT:
            return {...state, isSignedIn: false, userId: null}

        default:
            return state
    }
}














??????QUESTION?????? make sure you have redux devtools extension installed and wired up to your project
import {createStore, applyMiddleware, compose} from "redux";

const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose
const store = createStore(reducers, composeEnhancers(applyMiddleware()))
??????QUESTION?????? what is the use of localhost:3000?debug_session=nameOfTheSession










///////////////////////
REDUX DEV TOOLS
///////////////////////


we're going to install an extension to our browser that is going to allow us to have a look at the data inside our redux store easily


this can be used to debug the redux store


Redux DevTools by remotedevio (https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd?hl=en)


install this from webstore then we'll hook up our app to this extension


root index.js

import {createStore, applyMiddleware, compose} from "redux";

const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose
const store = createStore(reducers, composeEnhancers(applyMiddleware()))


we don't have any middleware yet but we will eventually have redux thunk installed later. nonetheless we can still call applyMiddleware() without passing anything and not get an error


we will open our browser and test this redux dev tools extension. you should see the extension icon light up


clicking on it is going to expand the redux dev tools. you can open it as a window too


localhost:3000?debug_session=nameOfTheSession

running this on the browser is going to start a debug session which is going to save all data in redux store between page refreshes

anytime your done with a debug session, remember to delete the query string














??????QUESTION?????? install redux-form using npm i redux-form --legacy-peer-deps
??????QUESTION?????? explain the follow of a form using redux-form













/////////////////////
REDUX FORM
/////////////////////



we're now going to work on our CreateStream component which is going to use a form for submitting the title and description of the stream


we will then submit this to an external api server which we said will be storing the list of streams


for forms, we're going to use a library called redux form which sometimes can be challenging to understand


apparently installing redux-form to the latest node and npm version causes an error when we run npm i redux-form

code ERESOLVE

npm ERR! ERESOLVE unable to resolve dependency tree


run this command instead
~ npm install redux-form --legacy-peer-deps



upto this point in the course, we've been handling forms using controlled input elements and component level state management


using redux means this approach is going to change as we want to hold all our data in our redux store


our input element will have an onChange handler which will call an action creator, the action creator will be dispatched to the reducer and taken to the redux store


using mapStateToProps, the value from the store will be passed to the component as props and stored as the value


redux-form does the transferring data from the input element to the store and back to the input element automatically


we're not going to write any action creator, reducer nor mapStateToProps, redux form will do this for us


we can find some very useful examples of redux form from redux form documentation examples e.g simple form, client side validation form, submit validation form, initializing from state form i.e edit form, wizard form which has multiple stages of submitting


we're going to use a synchronous validation form example in this case
















??????QUESTION?????? wire up redux form to your project
(HINT!! this process is automatic therefore we only need to wire up our combineReducer to redux-form)












we're now going to wire up redux form to our project


open reducers index.js file

we will not create a reducer as this is already done by redux-form, we will just import this instead

import {reducer} from "redux-form";


we then have to wire this to a specific key in our combineReducers for the automation to work


export default combineReducers({
    auth: authReducer,
    form: reducer
})



reducer is a named export from redux-form, however the name reducer can be confusing and unclear. you will find that most people rename this. this is how we rename a named export

import {reducer as formReducer} from "redux-form";


we will then update the name in our combineReducers

form: formReducer













??????QUESTION?????? refactor StreamCreate to a class based component
??????QUESTION?????? wire up redux form to this component. it should contain only two inputs for now, name and title. submitting will be done in the next question, skip
??????QUESTION?????? use the styles below for the input and the form
input
    <div className="field">
        <label>//label</label>
        <input />
    </div>

form
    <form className="ui form">
        //inputs
    </form>









we will now start working on our StreamCreate component. navigate to http://localhost:3000/streams/new
in your browser and open it in your code editor as well


refactor your code to a class based component


import two helper functions form redux-form

import {Field, reduxForm} from "redux-form";


Field is a react component and reduxForm is a function which will have the same functionality as the connect function. it will make sure we call the action creator and get data from the state using mapStateToProps automatically


we will first hook up our reduxForm function which has a similar sytanx to the connect function


as the first argument, we will pass an object with some configuration. for now we will only pass form which will contain the name of the form

export default reduxForm({
    form: 'streamCreate'
})(StreamCreate)



this component is now going to be passed a ton of props that were not being passed before. we can add a console log of props inside the render function. from this we will only use the ones needed to create our form



return a form from this component and pass Field which is essentially some type of input element


we need to provide some number of props to this field tag

1. name
2. component - this is going to be a react component or a function for the field to call which will return an element which will be shown on the screen

    <form>
        <Field name="title" component={this.renderInput} />
        <Field name="description" component={this.renderInput}/>
    </form>

we will create a function called renderInput which we will pass to this component prop. we will return a controlled input element from this function


in order to make this a controlled element, we have to pass a prop to this function


the prop that is passed to this function contains an input object which contains the name, value and some functions like onChange

    renderInput(formProps){
        return(
            <input onChange={formProps.input.onChange} value={formProps.input.value}/>
        )
    }


we can have a look at our redux devtools extension to note these updates on the state



there is a much cleaner way of writing this renderInput function


    return <input {...formProps.input} />


this is going to destructure the input object and pass in all the key and value pairs as properties to the input element


as a way of shortening this further, we can destructure input from the formProps object

    renderInput({input}){
        return(
            <input {...input} />
        )
    }


we're now going to customize our form fields, add some styling and some label


we will pass the label as a prop to Field. anytime we add props to our Field components, redux form is going to see that we have passed some prop that it doesn't know what to do with


so the Field element by default, is going to take this prop and pass it to the renderInput function and it can be received as an additional property to the formProps object. since we're already destructuring input, we will destructure this as well


    renderInput({input, label}){
        return(
            <div className="field">
                <label>{label}</label>
                <input {...input} />
            </div>
        )
    }

    render() {
        return(
            <form className="ui form">
                <Field name="title" component={this.renderInput} label="Enter Title" />
                <Field name="description" component={this.renderInput} label="Enter Description" />
            </form>
        )
    }

















??????QUESTION?????? add a submit button using the styles below and console log the values of the form on submit
    <button className="ui button primary">Submit</button>













we will now start working on handling form submission


as we had mentioned earlier, redux form adds several props to StreamCreate


there is one particular prop called handleSubmit which is the function that we're supposed to call when the function is submitted


we will pass a helper function to this which is going to receive formValues as an argument. handleSubmit is going to process the form and when it is done it will call our custom function

    <form onSubmit={this.props.handleSubmit(this.onSubmit)} className="ui form">

helper function onSubmit

    onSubmit(formValues){
        console.log(formValues);
    }

we will also add a button to test this submission

    <button className="ui button primary">Submit</button>














??????QUESTION?????? set up form validation where by a user can not submit a blank input to both title and description. in the case of an error, show it using the classes below
    <form className="ui form error">

and

   <div className="ui error message">
        <div className="header">//error</div>
    </div>














we're now going to do some form validation to prevent actions like submitting the form without any data


we're going to define a validate function outside the class which is going to be called with a formValues object


we'll then check if the form values submitted contain valid data


if the user entered valid inputs, we will return an empty object which makes redux form think our form is valid


if the user enters invalid inputs, we will return an object where for each invalid field, we will put a key value pair with the name of the field and the error message e.g {title : 'Title should not be blank'}. this will make redux form rerender our component


we will write this function outside the class

const validate = (formValues) => {
    const errors = {}

    if (!formValues.title){
        errors.title = 'You must enter a title'
    }

    if (!formValues.description){
        errors.description = 'You must enter a description'
    }

    return errors
}


we will then wire this function to redux form on a key called validate

export default reduxForm({
    form: 'streamCreate',
    validate: validate
})(StreamCreate)


this function is going to be run when our form is initially rendered or when a user interacts with it with all the values from the form


if our error object has a property with the same name as the Field name, redux form is going to take that error message and pass it to the renderInput function of that Field


we will destructure meta in our renderInput method which contains the errors

    renderInput({input, label, meta}){
        return(
            <div className="field">
                <label>{label}</label>
                <input {...input} />
                <div>{meta.error}</div>
            </div>
        )
    }


this is now working, however we only want to show the error message when a user clicks onto a field, enters some text and then clicks out of it


the meta object contains a property called touch which is a boolean


we will create a helper function called renderError which is going to be passed the meta object


running this is going to cause an error due to this which we can solve by converting renderInput to an arrow function

    renderError = ({error, touched}) =>{
        if (error && touched){
            return(
                <div className="ui error message">
                    <div className="header">{error}</div>
                </div>
            )
        }
    }

    renderInput = ({input, label, meta}) => {
        console.log(meta)
        return(
            <div className="field">
                <label>{label}</label>
                <input {...input} />
                <div>{this.renderError(meta)}</div>
            </div>
        )
    }


this is now working well, the error div is added to the screen however semantic ui is hiding the error by giving it a style of display none


this can be fixed by adding a class error to the form

className="ui form error"















??????QUESTION?????? inside streams (main folder of our project which contains client) create a new folder called api and set up a json-server which follows rest conventions that we will use to store our list of streams
STEP BY STEP INSTRUCTIONS
- in streams, create a new folder called api
- open a new terminal and cd into api
- install json-server (npm i json-server)
- run npm init and accept all/ npm init -y
- create a new file called db.json which will contain a property called streams which will be equal to an empty array
- create a start script 'json-server -p 3001 -w db.json' and run it on the terminal













//////////////////////
REST BASED REACT APPS
//////////////////////


our StreamCreate form is now complete. we now need to think what to do when a user finally submits the create stream form


we need to think of how to reach to the api server that will be storing a list of all the streams broadcasting


the api server is going to have a list of streams. each stream will have an id, title and description


when a user selects a stream, the id will be taken to the RMTP server which is going to connect them to the streamers computer of the same id


we need to work on the api server before we can progress further with our app


we're going to use a package called json-server which uses REST conventions


open another terminal window and go to streams directory where we will create a second project folder which will contain code for the json-server api. these are going to be two completely separate servers


create a new folder called api and cd into it


run npm init and accept all by pressing enter and we will have a package.json file


we can now install json-server
~ npm i json-server


we can create a db.json file then any record that we store to this api server will be automatically stored inside this file


inside api, create a new file called db.json and add some json to it

{
    "streams": []
}


as we start to create some streams in our app, they're going to be added as json records in this array


we're then going to open our package.json file, delete the test script and write a start up script

  "scripts": {
    "start": "json-server -p 3001 -w db.json"
  },

this is going to start the server on port 3001 and it is going to watch db.json for any changes that get made to it


run npm start and thats basically all we need to do to start our server


now we can make rest calls to localhost:3001/streams

















??????QUESTION?????? using axios and redux thunk, create an action creator that will add a stream to our api server. for now, don't focus on the dispatch, just set up an action creator that adds the stream to our api server. run it on the browser to test this
??????QUESTION?????? after a successful test, finish up your action creator (the reducer will be created in the next set of questions, not now)











now anytime a user submits a create stream form, we attempt to make an network request to our api running on localhost 3001


to make a network request, we're first going to define and action creator, wire it up to StreamCreate and call it onSubmit


our action creator is then going to make a network request using axios to our api


in client terminal, install axios and redux thunk


create a folder called apis and set up a preconfigured instance of axios


create a new file called streams.js

import axios from "axios";

export default axios.create({
    baseURL: 'http://localhost:3001'
})


in action/index.js, we're going to import that streams api axios

import streams from "../apis/streams";


create a new action creator to handle this creation

export const createStream = (formValues) => {
    return async (dispatch) => {
        streams.post('/streams', formValues)
    }
}


for now we're only going to post this and test if the stream is added to our api, we're not going to do the dispatch bit



in StreamCreate, import connect and the action creater we've just created


import {connect} from "react-redux";
import {createStream} from "../../actions";


we however have already wired up redux-form the same way we would have wired up the connect function


export default connect()(redux-form-code)


save the redux-form code in a variable to make the code neater


const formWrapped = reduxForm({
    form: 'streamCreate',
    validate: validate
})(StreamCreate)

export default connect(null, {createStream})(formWrapped)


we don't have a mapStateToProp function yet so we will just pass null then pass createStream action creator


inside the onSubmit function, we will use our action creator which will be passed as a prop and call it with our form values. we will also convert it to an arrow function to aviod issues with this

    onSubmit = (formValues) =>{
        this.props.createStream(formValues)
    }


to test this we will now wire up redux-thunk in root index. we have already set up the applyMiddleware so this is going to be easy


import reduxThunk and pass it to applyMiddleware

const store = createStore(reducers, composeEnhancers(applyMiddleware(reduxThunk)))


we can test this by trying to create a stream and looking if it will be added to our api server


we will now finish up writing our action creator. we will await our post request and save it in a variable called response. this will from our action payload


however, we will first create our action type from action/types

export const CREATE_STREAM = 'CREATE_STREAM'


import this and dispatch it

    dispatch({type: CREATE_STREAM, payload: response.data})















??????QUESTION?????? given that we're using REST conventions and we know the routes and responses that we will get, create the other action creators for our project i.e fetch streams, fetch stream,












since we're using REST conventions, we can know what type of response we will get from each call i.e
GET to /streams will return an array of streams
GET to /streams/:id will return a single record
POST to /streams will return a new record after creating it
PUT to /streams/:id will return a single record after edit/ update
DELETE to /streams/:id will return nothing after deletion




with this we can create all the action creators right now


the first thing we're going to do is create types


export const FETCH_STREAMS = 'FETCH_STREAMS'
export const FETCH_STREAM = 'FETCH_STREAM'
export const EDIT_STREAM = 'EDIT_STREAM'
export const DELETE_STREAM = 'DELETE_STREAM'


import this in actions


we will now write an action creator to fetch a list of all the streams


export const fetchStreams = () => {
    return async (dispatch) => {
        const response = await streams.get('/streams')

        dispatch({type: FETCH_STREAMS, payload: response.data})
    }
}

export const fetchStream = (id) => async dispatch => {
    const response = await streams.get(`/streams/${id}`)

    dispatch({type: FETCH_STREAM, payload: response.data})
}


for the edit stream, we will need to provide the id and the update that we want to make to that stream as the updates to save

export const editStream = (id, formValues) => async dispatch => {
    const response = await streams.put(`/streams/${id}`, formValues)

    dispatch({type: EDIT_STREAM, payload: response.data})
}


for delete, we don't need to save the response in a variable cause we get nothing as the response. we will also pass the id as the payload. this is going to make sense later

export const deleteStream = (id) => async dispatch => {
    await streams.delete(`/streams/${id}`)

    dispatch({type: DELETE_STREAM, payload: id})
}















??????QUESTION?????? which data type is more suited to store our streams in our redux store and why?
HINT!!! use editing a stream reducer to compare which data type is easier to update














we're going to take a similar approach for our reducers as well. we will start with out streams reducer


we're going to do things a little bit differently than the way we've done in the past


we can have a streamsReducer that always returns an array of objects. this is the way we have been creating our reducers


in this case, we're still going to have a streamsReducer but instead of returning an array, it is going to return an object which has all the streams inside of it


in this object we're going to have a collection of key - value pairs, the key is going to be the id of the stream and the value is going to be the stream with that id


this makes accessing the streams a little bit easier as once we get this object we will just try to find the stream using id which are the keys


other than making it easier to access our streams, modifying and updating data is going to be easier as well

to update a record in an array, we will use
return state.map(stream => stream.id === action.payload.id ? action.payload : stream)


to update an object, we will use
{...state, [action.payload.id]: action.payload}

which is much more straight forward














??????QUESTION?????? create streamReducer and wire it up to the project. this reducer will be used for all action creators (HINT!! use lodash to assist). to test this make sure you have no errors in your console












we're now going to work on our streamReducer. create streamReducer.js in reducers


import the action type file

creating, fetching and editing a stream are going to be exactly the same

to delete, we're going to use lodash and also note that we had passed the id for the deleted stream as the payload


lodash omit requires us to pass the object and the key we want to remove. in our case, the id is the key and we pass the id as the payload in our action


the nice thing about omit is that it is not going to change the original object but instead create a new object minus the deleted key


for the fetch streams, we're going to merge the response from our fetch streams call to our redux store. this would have been easier if we were using an array as we would only have to concatenate the two arrays to merge them but since we're using an object we need to figure another way out


the response we get back from our api is an array of objects containing stream details


in order to get this merged into our object we're going to use a function from lodash called mapKeys which is a function that is going to take an array an return an object with the items of the array being the values of this object

mapKeys(streams,'id') will create an object with the ids from each stream as the keys


import _ from "lodash"
import { CREATE_STREAM, FETCH_STREAMS, FETCH_STREAM, EDIT_STREAM, DELETE_STREAM} from '../actions/types'

export default (state = {}, action) => {
    switch (action.type) {
        case CREATE_STREAM:
            return {...state, [action.payload.id]: action.payload}
        case FETCH_STREAM:
            return {...state, [action.payload.id]: action.payload}
        case EDIT_STREAM:
            return {...state, [action.payload.id]: action.payload}
        case DELETE_STREAM:
            return _.omit(state, action.payload)
        case FETCH_STREAMS:
            return {...state, ..._.mapKeys(action.payload, 'id')}
        default:
            return state
    }
}



we will then import this in reducers index and add it to combineReducers

export default combineReducers({
    auth: authReducer,
    form: formReducer,
    streams: streamsReducer
})











??????QUESTION?????? to test this out, we will wire up fetchStreams action creator in StreamList. refactor StreamList to a class component and wire the action creator. just use mapStateToProps as null and you don't have to render on the screen, confirm that we receive our streams in redux devtools











to test this out, were going to wire up our StreamList component. anytime this is rendered, we're going to attempt to fetch a list of all of our streams



also refactor this component to a class component


you can check redux devtools if we receive the list of all the streams


class StreamList extends React.Component{

    componentDidMount() {
        this.props.fetchStreams()
    }

    render() {
        return(
            StreamList
        )
    }
}

export default connect(null, {fetchStreams})(StreamList)













??????QUESTION?????? render the streams using the styles below
    <div className="item" >
        <i className="large middle aligned icon camera" />
        <div className="content">
            // stream title
            <div className="description">//stream description</div>
        </div>
    </div>
??????QUESTION?????? call the list of streams in render using the styles below
    <div>
        <h2>Streams</h2>
        <div className="ui celled list">//stream list</div>
    </div>










we will now attempt to render the streams on the screen. to get this list of streams into our component we will first define our mapStateToProps function


since the list of streams is stored as an object in our redux store for easier modification reasons, inside our component, an array of streams will be much more useful


inside our mapStateToProps, we will convert the object into an array so that an array is passed into the component


to do this, we're going to use a built in js function called Object.values. this is going to take an object as an argument. all the different values of the object are going to be pulled out then inserted into an array

const mapStateToProps = (state) => {
    return {streams: Object.values(state.streams)}
}


we will map through this array and use the styles below


    renderList = () =>{
        return this.props.streams.map(stream => {
            return (
                <div className="item" key={stream.id}>
                    <i className="large middle aligned icon camera" />
                    <div className="content">
                        {stream.title}
                        <div className="description">{stream.description}</div>
                    </div>
                </div>
            )
        })
    }




and call it in render using the styles below

    <div>
        <h2>Streams</h2>
        <div className="ui celled list">{this.renderList()}</div>
    </div>

















??????QUESTION?????? show an edit or delete buttons on the streams that a user has created. use the classes below to style the buttons
    <div className="right floated content">
        <button className="ui button primary">Edit</button>
        <button className="ui button negative">Delete</button>
    </div>
place this before the i tag in your steam list items
    <div className="item" key={stream.id}>
        //edit/ delete stream buttons
        <i className="large middle aligned icon camera" />












we now want to show an edit or delete buttons on the streams that a user has created


in order to figure out the creator of a stream, we need to attach a user id to our streams when they get created. we will use the id from our google authentication auth piece of state


we store the user id in our state too when the user is successfully logged in. we can use this to pass the user id when creating our stream in our action creator

export const createStream = (formValues) => {
    return async (dispatch,getState) => {
        const {userId} = getState().auth
        const response = await streams.post('/streams', {...formValues, userId})        //userId: userId is same as userId
        dispatch({type: CREATE_STREAM, payload: response.data})
    }
}


this change isn't going to be applied to the streams we had created earlier but that's a good thing so that we can show the edit button on some


create a new stream with this new action creator


we will go to StreamList and first ensure that this component understands the userId concept. if the userId in the stream is equal to the userId of the auth piece of state, we want to show the delete and edit buttons


we will pass the userId to our props in mapStateToProps

const mapStateToProps = (state) => {
    return {
        streams: Object.values(state.streams),
        currentUserId: state.auth.userId
    }
}



we will then add some logic to compare the userId for the signed in user to the userId in the stream


    renderAdmin = (stream) => {
        if (stream.userId === this.props.currentUserId){
            return(
                <div className="right floated content">
                    <button className="ui button primary">Edit</button>
                    <button className="ui button negative">Delete</button>
                </div>
            )
        }
    }


we will then call this function before the i tag for the semanic ui classes to work

    <div className="item" key={stream.id}>
        {this.renderAdmin(stream)}
        <i className="large middle aligned icon camera" />













??????QUESTION?????? create a create stream button at the bottom of the stream list which will only show for users who have logged in. use the styles below
    <div> // give this div a style of text align right
        //create stream button should have classes of ui button primary and it should take the user to create stream page on click
    </div>












the next thing we want to do is to create a create stream button on the bottom of StreamList if a user is logged in

we can use the userId property in our redux store to check if the user is signed in. however we also have a property called isSigned in which tells us the auth status of the user as well which was created for such purposes


we will add isSigned in to our mapStateToProps function

const mapStateToProps = (state) => {
    return {
        streams: Object.values(state.streams),
        currentUserId: state.auth.userId,
        isSignedIn: state.auth.isSignedIn
    }
}


use react router to link the pages

import {Link} from "react-router-dom";

    renderCreate = () => {
        if (this.props.isSignedIn){
            return(
                <div style={{textAlign: 'right'}}>
                    <Link to="/streams/new" className="ui button primary">
                        Create Stream
                    </Link>
                </div>
            )
        }
    }


call it after the streams list
    <div className="ui celled list">{this.renderList()}</div>
    {this.renderCreate()}













??????QUESTION?????? what are the two types of navigation in react router
??????QUESTION?????? explain how to do programmatic navigation using react router
??????QUESTION?????? follow the notes below to do a programmatic navigation when a user submits the create stream from. it should take them to stream list










there are two types of navigation
1. intentional navigation - when a user clicks on a Link component
2. programmatic navigation - we run code to forcibly navigate the user through our app


an example of programmatic navigation is a user submits the create stream form. we make a request to backend API to create the stream. API responds with success of error. we either show error to the user or navigate them to the list of streams


we only want to trigger navigation from our action creator createStream only when we get a successful message from our API


its more ideal to do our navigation after we dispatch our action


internally, the BrowserRouter create the history object which keeps track of the address bar in the browser. the history object also has the ability to change the address bar as well


it is a little bit challenging to get this history object to the action creator or any other non react component and also because the BrowserRouter is the one responsible for creating and managing the history object


the solution to this would be us creating the history object instead of the BrowserRouter in a specific file. then anytime we want to get access to the history object we will just import it


because we're now creating our own history object, we're no longer going to create a BrowserRouter object as the top of our component hierarchy


inside src, create a file called history.js

import { createBrowserHistory } from 'history';

export default createBrowserHistory();


the next thing is to create a custom router instead of BrowserRouter. create a new file in src called CustomRouter

import React from "react";
import {Router} from 'react-router-dom';

export const CustomRouter = ({basename, children, history}) => {
    const [state, setState] = React.useState({
        action: history.action,
        location: history.location,
    });

    React.useLayoutEffect(() => history.listen(setState), [history]);

    return (
        <Router
            basename={basename}
            children={children}
            location={state.location}
            navigationType={state.action}
            navigator={history}
        />
    );
};


anytime we pass history as a prop, the router is going to use this instead of its default history object


we will then replace BrowserRouter with CustomRouter in index.js
import {CustomRouter} from "./CustomRouter";
import history from "./history";

root.render(
    <Provider store={store}>
        <CustomRouter history={history}>
            <App/>
        </CustomRouter>
    </Provider>
)

we will then import history in our action creators file

import history from "../history";

then call it after the dispatch of createStream

    dispatch({type: CREATE_STREAM, payload: response.data})
    history.push('/')














??????QUESTION?????? what are the two ways we can use to navigate to the edit stream page to show the specific stream user has selected to edit
??????QUESTION?????? using url based selection, wire up the edit button which will show the default StreamEdit component (prints out StreamEdit) when a user clicks on the edit button
??????QUESTION?????? print out the title of the stream on edit stream. experienced errors with react router v6 while watching tutorial so use a functional component to achieve this (HINT!! access details from the url using the history object which can be accessed outside react components)














we're now going to work on the edit stream button. this will allow a user to edit the title or description of a stream they had created


we can use two approaches to communicate the stream that the user is trying to edit

1. selection reducer - when a user clicks on a stream to edit it, use a selectionReducer to record what stream is being edited
2. url based selection - put the id of the stream being edited in the URL


we're going to use url based selection which will work for edit, show and delete


we can make use of react router dom, we will look at the url and pull of the id portion of the url. we will pass this as a prop to the StreamEdit component


first we're going to update our edit stream button to make sure the id of the stream is passed to the url


StreamList, renderAdmin()

    <Link to={`/streams/edit/${stream.id}`} state={{ streamId: stream.id }} className="ui button primary">Edit</Link>

state is going to pass the id into the history object which we will use to access the id


then we're going to do a little tweak around our routing tools to support url based selection

App.js

    <Route path="/streams/edit/:id" element={<StreamEdit/>}/>


the next step is going to be to communicate the id to the StreamEdit component



inside the mapStateToProps, we can get access to our redux store to access a list of all the streams. inside this function, we can also access the id of the stream that we had passed in the url and is contained in the props of our component

const mapStateToProps = (state) => {
    return {stream: state.streams[history.location.state.streamId]}
}

we can now access the selected stream inside our component. However, theres a subtle error that might occur. in the case a user goes to /streams/edit/id directly

you can test this by adding a console log props to our component


our app needs StreamList to load the list of streams first before it passes it to StreamEdit. going directly to StreamEdit means that we haven't loaded our list of streams first therefore the error


this is against react router rules as every component should be independent and should work in isolation. StreamEdit is supposed to fetch the stream without needing help from StreamList


to fix this, we will use our fetchStream action creator when our component mounts. import fetchStream and pass to connect




final code StreamEdit.js



import React, {useEffect} from "react";
import history from "../../history";
import {connect} from "react-redux";
import {fetchStream} from "../../actions";

const StreamEdit = ({fetchStream, stream}) => {

    useEffect(() => {
        fetchStream(history.location.state.streamId)
    }, [])

    if (!stream) {
        return (
            <div>Loading ...</div>
        )
    }

    return(
        <div>
            {stream.title}
        </div>
    )
}

const mapStateToProps = (state) => {
    return {stream: state.streams[history.location.state.streamId]}
}

export default connect(mapStateToProps, {fetchStream})(StreamEdit)












??????QUESTION?????? since the create stream and edit stream pages are somehow similar, create a StreamForm component which we will reuse for creating the form that will be used in StreamCreate and StreamEdit











since the create stream and edit stream pages are somehow similar, we can create a StreamForm component which we will reuse for creating the form

import React from 'react';
import { Field, reduxForm } from 'redux-form';

class StreamForm extends React.Component {
  renderError({ error, touched }) {
    if (touched && error) {
      return (
        <div className="ui error message">
          <div className="header">{error}</div>
        </div>
      );
    }
  }

  renderInput = ({ input, label, meta }) => {
    const className = `field ${meta.error && meta.touched ? 'error' : ''}`;
    return (
      <div className={className}>
        <label>{label}</label>
        <input {...input} autoComplete="off" />
        {this.renderError(meta)}
      </div>
    );
  };

  onSubmit = formValues => {
    this.props.onSubmit(formValues);
  };

  render() {
    return (
      <form
        onSubmit={this.props.handleSubmit(this.onSubmit)}
        className="ui form error"
      >
        <Field name="title" component={this.renderInput} label="Enter Title" />
        <Field
          name="description"
          component={this.renderInput}
          label="Enter Description"
        />
        <button className="ui button primary">Submit</button>
      </form>
    );
  }
}

const validate = formValues => {
  const errors = {};

  if (!formValues.title) {
    errors.title = 'You must enter a title';
  }

  if (!formValues.description) {
    errors.description = 'You must enter a description';
  }

  return errors;
};

export default reduxForm({
  form: 'streamForm',
  validate
})(StreamForm);














??????QUESTION?????? refactor StreamCreate to use StreamForm. create a new stream to test if this works correctly












with this, we're going to refactor StreamCreate and reuse StreamForm with it



we don't need Field and reduxForm anymore

import StreamForm that we just created

delete renderError, renderInput

we need some onSubmit call back that will be used to create the stream. this will be passed down to StreamForm as a prop

inside our render method, we're not going to show a form anymore, the entire render method jsx can be removed. we will replace that with a header and StreamForm passing onSubmit as a prop

delete validate function and formWrapping

export default will be just a normal connect function passing createStream action creator and StreamCreate


import React from "react";
import {connect} from "react-redux";
import {createStream} from "../../actions";
import StreamForm from "./StreamForm";

class StreamCreate extends React.Component{

    onSubmit = (formValues) =>{
        this.props.createStream(formValues)
    }

    render() {
        return(
            <div>
                <h3>Create Stream</h3>
                <StreamForm onSubmit={this.onSubmit}/>
            </div>
        )
    }
}

export default connect(null, {createStream})(StreamCreate)


create a stream to test if this works well like before











??????QUESTION?????? use StreamForm in StreamEdit, for now the onSubmit function should just console log the data from the form. test to make sure it works











StreamEdit is going to be similar to StreamCreate. they're both going to use StreamForm. however for StreamEdit, we will need to pass the inital values of the stream to StreamForm so that they can be edited


we will pass these inital values to StreamForm as a prop together with the onSubmit function


we can do this easily with reduxForm. in our export statement, we wrap our StreamForm with reduxForm


this means that when we pass props to StreamForm, we're not directly passing the props to StreamForm but instead to reduxForm first which gets them to StreamForm


there are some special props that we can pass to the reduxForm that will handle the initial values


if we pass some prop called initialValues to reduxForm, it is going to show the inital values on the inputs in StreamForm


in StreamEdit, import editStream from our action creators and StreamForm

import {fetchStream, editStream} from "../../actions";
import StreamForm from "./StreamForm";


we will then define an onSubmit function which will be our callback function when the form is submitted passed down to StreamForm as a prop. for now we will just console log the form values

    const onSubmit = (formValues) => {
        console.log(formValues)
    }


in our return function, instead of returning the stream title we will return a title Edit Stream with the form. we will pass two props, onSubmit and initialValues

the initalValue prop accepts on object when the name of the field is the key, it will then display the value of the field i.e {{title: 'Title to be edited'}}. it happens that our stream variable is an object with keys name and description therefore we can pass this streams object in initialValues selecting only the keys we need from streams. {{ title : stream.title, description: stream.description}}. we can also use lodash which is more precise

    if (!stream){
        return <div>Loading...</div>
    }

    return(
        <div>
            <h3>Edit Stream</h3>
            <StreamForm initialValues={_.pick(stream, 'title', 'description')} onSubmit={onSubmit} />
        </div>
    )


in the export default, we will pass our editStream action creator as well

export default connect(mapStateToProps, {fetchStream, editStream})(StreamEdit)


test this in the browser to see if you get a form in StreamEdit














??????QUESTION?????? when the StreamEdit form is submitted is to update the stream rather than the console log












the last thing we want to do when our StreamEdit form is submitted is to update the stream rather than the console log


    const onSubmit = (formValues) => {
        editStream(history.location.state.streamId, formValues)
    }


we will then do a programmatic navigation back to the list of streams after the dispatch of the editStream action creator

export const editStream = (id, formValues) => async dispatch => {
    const response = await streams.put(`/streams/${id}`, formValues)

    dispatch({type: EDIT_STREAM, payload: response.data})
    history.push('/')
}


this will work, however you will notice that the edit and delete button for the edited stream disappear


we only show the edit and delete button when the userId in the stream is equal to the id of the signed in user. however after updating, our stream loses the userId property


this error is caused by the restful convention we're using to update, i.e put.


put updates all properties of a record. the id property is usually immune to this


patch updates some properties of a record


in this case we want to use patch instead of put therefore we will update our action creator

export const editStream = (id, formValues) => async dispatch => {
    const response = await streams.patch(`/streams/${id}`, formValues)

    dispatch({type: EDIT_STREAM, payload: response.data})
    history.push('/')
}



















??????QUESTION?????? what is a react portal and what are they used for
??????QUESTION?????? create a modal on StreamDelete which will have the following styles. test to see if it works
    <div className="ui dimmer modals visible active">
        <div className="ui standard modal visible active">
            <div className="header">Delete Stream</div>
            <div className="content">Are you sure you want to delete this stream?</div>
            <div className="actions">
                <button className="ui button negative">Delete</button>
                <button className="ui button">Cancel</button>
            </div>
        </div>
    </div>













/////////////////////
REACT PORTALS
/////////////////////


we will now start working on the delete stream page


when the user goes to this page, we're going to show a modal


modals with react can be a little bit challenging because all of our elements are nested in the index.html file which has an id of root


we will use a feature in react called portals to get around this issue of having to nest all our components in the root div


oue modal might be deeply nested in our componenets therefore it will be difficult to implement the css classes for it showing over everything


this is why we use portals which allows us to render some element not as a direct child but as a child of some other element inside our html structure most commonly our body tag. this will make it on the same level of hierarchy as the root div


we will create our modal as a reusable component where we can show anything. in this case it will show the confirmation of deleting a stream


inside components, create a new file called Modal.js


the return is going to be a little different that our normal jsx


ReactDOM.createPortal is going to take two arguments
1. some blob of jsx, something that we want to show on the screen
2. code to attach the code to our body element. this is by going to some div which is another child of body like root (sibling to root)

import React from "react";
import ReactDOM from "react-dom"

const Modal = (props) => {
    return ReactDOM.createPortal(
        <div className="ui dimmer modals visible active">
            <div className="ui standard modal visible active">
                <div className="header">Delete Stream</div>
                <div className="content">Are you sure you want to delete this stream?</div>
                <div className="actions">
                    <button className="ui button negative">Delete</button>
                    <button className="ui button">Cancel</button>
                </div>
            </div>
        </div>,
        document.querySelector('#modal')
    )
}

export default Modal


we will create this sibling of id root inside public index.html

    <div id="root"></div>
    <div id="modal"></div>




the next thing is going to attempt to show this on the screen in StreamDelete and import Modal

        <div>
            StreamDelete
            <Modal />
        </div>

we can then navigate to /streams/delete manually to test this













??????QUESTION?????? make the modal close when a user clicks outside the modal











we now want to close the modal when a user clicks outside it


we can do this by changing the url as the modal is only shown at /streams/delete


we will import our history object for this

    <div onClick={() => history.push('/')} className="ui dimmer modals visible active">
        <div onClick={event => event.stopPropagation()} className="ui standard modal visible active">


the click for the first div takes the user to / and a click on the modal itself will prevent the event propagation/ bubbling as we don't want the modal to close when the user clicks the modal itself and to only close when clicked outside












??????QUESTION?????? make our modal reusable and dynamic by removing the hard coded content
 i.e title,
     content: just print are you sure you want to delete? we will load up the stream title in the next question
     buttons: use the styles below. NOTE!! they shouldn't be wrapped in a div as it affects the styling
                 <button className="ui button negative">Delete</button>
                 <button className="ui button">Cancel</button>
    onDismiss function which returns the user to StreamList










our next step is to make our modal reusable as it contains some hard coded content


we're going to pass some props in StreamDelete


    const action = (
        <React.Fragment>
            <button className="ui button negative">Delete</button>
            <button className="ui button">Cancel</button>
        </React.Fragment>
    )
    return(
        <div>
            StreamDelete
            <Modal
                title="Delete Stream"
                content="Are you sure you want to delete this stream?"
                action={action}
                onDismiss={() => history.push('/')}
            />
        </div>
    )

we use React.Fragment for action because using a div affects the semantic ui styling

you can shorten React.Fragment to be <></>

    const action = (
        <>
            <button className="ui button negative">Delete</button>
            <button className="ui button">Cancel</button>
        </>
    )


these will then be passed to Modal.js as props












??????QUESTION?????? load the stream in StreamDelete so that it displays Are you sure you want to delete //stream title. wire up the delete and cancel functionality as well











we will then need to load the stream to be deleted so that we can print the title of the stream in the content section


we will first update the route to support url based selection

<Route path="/streams/delete/:id" element = { <StreamDelete /> } />


we will then update the link of delete button on StreamList. pass the id as state so that it can be accessible anywhere in StreamDelete and not necessarily in a react componenet

    <Link to={`/streams/delete/${stream.id}`} state={{ streamId: stream.id }}  className="ui button negative"> Delete </Link>


StreamDelete.js, we will load the stream and wire up delete and cancel buttons

import React, {useEffect} from "react";
import {connect} from "react-redux";
import {Link} from "react-router-dom";
import {fetchStream, deleteStream} from "../../actions";
import Modal from "../Modal";
import history from "../../history";

const StreamDelete = ({fetchStream, stream, deleteStream}) => {

    useEffect(() => {
        fetchStream(history.location.state.streamId)
    }, [])

    const action = (
        <>
            <button onClick={() => deleteStream(history.location.state.streamId)} className="ui button negative">Delete</button>
            <Link to="/" className="ui button">Cancel</Link>
        </>
    )

    const renderContent = () => {
        if (!stream) {
            return 'Are you sure you want to delete this stream'
        }

        return `Are you sure you want to delete stream with title: ${stream.title}`
    }

    return (
        <Modal
            title="Delete Stream"
            content={renderContent()}
            action={action}
            onDismiss={() => history.push('/')}
        />
    )
}

const mapStateToProps = (state) => {
    return {stream: state.streams[history.location.state.streamId]}
}

export default connect(mapStateToProps, {fetchStream, deleteStream})(StreamDelete)



we will navigate users back to / after deleting

export const deleteStream = (id) => async dispatch => {
    await streams.delete(`/streams/${id}`)

    dispatch({type: DELETE_STREAM, payload: id})
    history.push('/')
}
















??????QUESTION?????? in StreamList give the title a class of header
??????QUESTION?????? display the title of a stream and description in StreamShow when a user clicks on the stream title on StreamList.












////////////////////////////
IMPLEMENTING STREAMING VIDEO
////////////////////////////

we're now going to work on the show stream page. the show stream page will have details of a stream and a video player


this implementation is going to be similar to what we've done to edit and delete stream using url selection

App.js

    <Route path="/streams/:id" element={ <StreamShow /> }/>


StreamList renderList()

    <Link to={`/streams/${stream.id}`} state={{streamId: stream.id}} className="header">{stream.title} </Link>


StreamShow

import React, {useEffect} from "react";
import {connect} from "react-redux";
import history from "../../history";
import {fetchStream} from "../../actions";

const StreamShow = ({fetchStream, stream}) => {

    useEffect(() => {
        fetchStream(history.location.state.streamId)
    }, [])

    if (!stream) return <div>Loading...</div>

    const {title, description} = stream

    return(
        <div>
            <h1>{title}</h1>
            <h5>{description}</h5>
        </div>
    )
}

const mapStateToProps = (state) => {
    return {stream: state.streams[history.location.state.streamId]}
}

export default connect(mapStateToProps, {fetchStream})(StreamShow)












??????QUESTION?????? follow the instructions below to set up rmtpserver and obs installation










the next step is now setting up the RMTP server and working on the streaming bit. this is going to be responsible for receiving different video streams and broadcasting them to different users


inside the main streams folder, create a new folder called rmtpserver and cd in a new terminal


~ npm init -y

~ npm install node-media-server


docs available at https://github.com/illuspas/Node-Media-Server#npm-version-recommended


we will use single core mode


open rmtpserver in code editor and create index.js and paste the code below

const NodeMediaServer = require('node-media-server');

const config = {
  rtmp: {
    port: 1935,
    chunk_size: 60000,
    gop_cache: true,
    ping: 30,
    ping_timeout: 60
  },
  http: {
    port: 8000,
    allow_origin: '*'
  }
};

var nms = new NodeMediaServer(config)
nms.run();





add start script to package.json

"scripts": {
    "start": "node index.js"
  },


run npm start


the rmtpserver makes video available for consumption in our browser at port 8000


this server also accepts traffic at port 1935 and that is where we're going to send incoming video streams to


we're now going to install obs which is going to allow us to stream our desktop


create a scene in obs

enter sources and display capture and audio input capture


you can start a recording at check to see if obs is set up correctly












??????QUESTION?????? follow the instructions below to implement video streaming










we're now going to implement the video player in ShowStream


we're going to use http-flv format for our videos


in our client terminal window, react-flv-player

~ npm i react-flv-player

StreamShow

import {ReactFlvPlayer} from 'react-flv-player'



we now want our video player to request the video from the rmtp server whereby we'll use flv


flv will download this video stream an convert it to some file that can be played in our normal html video player


    const url = `http://localhost:8000/live/${id}.flv`

    return(
        <div>
            <ReactFlvPlayer
                url = {url}
                width = "100%"
            />
            <h1>{title}</h1>
            <h5>{description}</h5>
        </div>
    )




we will now configure obs so that our rmtpserver can receive this video


obs > settings > stream
    - select custom streaming server
    - url rmtp://localhost/live
    - id put id of stream e.g 1

hit start streaming and you should start seeing you stream in StreamShow


this is the end of our streaming app


















??????QUESTION?????? create a new react app called translate. do the usual set up for a react app. App should be a class based component with the styles below
    <div className="ui container">
        Translate
    </div>
??????QUESTION?????? wire up semantic ui










//////////////////////////
CONTEXT SYSTEM
//////////////////////////



we're now going to talk about the context system in react


context system gets data from a parent component to any nested child component


it is similar to props system however props only get data from a parent component to a direct child component


to understand this, we're going to create a simple language selector app. anytime a user selects a language, we're going to render a form in that language (a label and a submit button)


when a user selects another language, we're going to rerender the form in the newly selected language


our app is going to have 4 components

App -> UserCreate -> Field & Button


App is going to contain the select language functionality.


if we we're using props system and we wanted to pass language from App to Field, we would have had to pass to USerCreate which will then in turn pass to Field


with context system, it is possible to pass language from App to Field directly


create a new react app called translate. do the usual set up for index and App which should be a class based component with the class ui container on the root div

        <div className="ui container">
            Translate
        </div>


we'll then wire up semantic ui












??????QUESTION?????? in App, using component level state with a piece called language which defaults to english, print on the screen two flags which on clicking update the value of language. print the value of language on the screen to make sure this work

        <div className="ui container">
            <div>
                Select a language
                <i className="flag us" onClick={() => this.onLanguageChange("english")} />
                <i className="flag nl" onClick={() => this.onLanguageChange("dutch")} />
            </div>
            {this.state.language}
        </div>











we will now put our language selector in App. we will make use of component level state. default it to english. we will then put two flags on the screen and wire them up to update the value of state language onClick passing the language of the flag clicked as an argument to this function. print on the screen the value of language to make sure this works

    class App extends React.Component{

        state = {language : "english"}

        onLanguageChange = (language) => {
            this.setState({language})
        }

        render() {
            return(
                <div className="ui container">
                    <div>
                        Select a language
                        <i className="flag us" onClick={() => this.onLanguageChange("english")} />
                        <i className="flag nl" onClick={() => this.onLanguageChange("dutch")} />
                    </div>
                    {this.state.language}
                </div>
            )
        }
    }















??????QUESTION?????? create the following components
UserCreate (functional)
        <div className="ui form">
            <Field />
            <Button />
        </div>
Field (class)
        <div className="ui field">
            <label>Name</label>
            <input />
        </div>
Button (class)
        <button className="ui button primary">Submit</button>
??????QUESTION?????? import Field and Button to UserCreate and UserCreate in App and replace the language print out with UserCreate











we're now going to put up the UserCreate, Field and Button components


UserCreate is a functional component containing Field and Button

        <div className="ui form">
            <Field />
            <Button />
        </div>

Field is a class component with the following styles

        <div className="ui field">
            <label>Name</label>
            <input />
        </div>

Button is a class component

        <button className="ui button primary">Submit</button>


then import Field and Button to UserCreate and UserCreate into App and print it out instead of the language piece of state print out
















??????QUESTION?????? what are the ways which you can add data to the context object in Parent and remove it in Child
??????QUESTION?????? create a context object called LanguageContext with the default value of "english". console log this default value in Button
??????QUESTION?????? if the value of context is english, print Name and Submit in Field and Button. if not print Naam and Voorlegen











we now want to communicate our language piece of state to Field and Button. we will use the context system for this


in order to communicate this info, we're going to create something called the context object which is going to move some data from parent to child


there are 2 ways to get information into our context object and 2 ways to get information out


to get data in, we can create something called default value when our context object is created or inside our parent component, we can create a component called a Provider which can push data into the context object


to get data out, we can reference this.context object or we can create a component called Consumer


inside src, create a new folder called contexts and inside it create LanguageContext.js


the purpose of this file is to create a context object and export it

import React from "react";

export default React.createContext()


we can now add data to our context object by adding a default value into the createContext call

export default React.createContext("english")


we will import LanguageContext in Button and try to access our default value in Button


we're first going to set up something called contextType which will link our Button component to the context object and then to reference information that is inside the context object we will use this.context

import LanguageContext from "../contexts/LanguageContext";


static contextType = LanguageContext

this is how we hook up a context object to a class component

static will add a property to our class which is an equivalent of writing Button.contextType = LanguageContext outside the class. either way will work


our component can now reference this.context and get access to the data inside our context object ("english")


inside render console log this.context


we will now update the value of text based on the value of our context object

    const text = this.context === "english" ? "Submit" : "Voorlegen"

print text instead of submit


we will do the same for the label in Field

    const text = this.context === "english" ? "Name" : "Naam"















??????QUESTION?????? update the context object to be the value of the language piece of state in App
??????QUESTION?????? explain the difference between the values of this.context in the code below (App.js)
        <LanguageContext.Provider value={this.state.language}>
            <UserCreate/>
        </LanguageContext.Provider>

        <LanguageContext.Provider value="dutch">
            <UserCreate/>
        </LanguageContext.Provider>

        <UserCreate/>















we're now going to look at how to update the value of the context object as we only have a default value at present


in order to change data inside our context object, we're going to create a component called Provider which is going to act as the source of information.


our Provider in this case is going to be App as it knows the value of the currently selected language


NOTE that this Provider is not the same as the one we made use on in redux


import LanguageContext from "../contexts/LanguageContext";


    <LanguageContext.Provider value={this.state.language} >
        <UserCreate />
    </LanguageContext.Provider>






if we console log the context object in LanguageContext.js, we will see that it contains a property called Provider which is a react component. calling LanguageContext.Provider automatically creates a react component for us.


there's also a Consumer property which we can use to get data from the context object


NOTEEEE!!!!!!! anytime we use the context system, a new pipe of information is created which doesn't overlap with the previous context systems


creating another context system and passing a different value will contain a different value for context than the first


also not using the provider will mean that this pipe of context system will always be using the default value of the context system. no overlap will happen between the 3


        <LanguageContext.Provider value={this.state.language}>
            <UserCreate/>
        </LanguageContext.Provider>
        // 1st pipe, value of content system will be equal to state.language and change respectively

        <LanguageContext.Provider value="dutch">
            <UserCreate/>
        </LanguageContext.Provider>
        // 2nd pipe, value of context will always be dutch

        <UserCreate/>
        //3rd pipe, no value passed therefore the value will always be the default value





















??????QUESTION?????? refactor Button to use a consumer instead of the this.context approach
??????QUESTION?????? why would someone use consumer approach instead of the this.context approach
??????QUESTION?????? create another context system that will be responsible for handling the color of our submit button. pass the value red from App to Button using this context system. place it in the class of button so that "ui button red" prints a red button instead of primary










we will now try to access data using Consumers


this Consumer component in somehow similar to the Provider component


we will refactor Button to use Consumer rather than this.context


delete
    static contextType = LanguageContext


Consumer should only have one child. this child is going to be a function which will be automatically called by the consumer with whatever value is in our context object as the first argument

            <button className="ui button primary">
                <LanguageContext.Consumer>
                    {(value) => value === "english" ? "Submit" : "Voorlegen"}
                </LanguageContext.Consumer>
            </button>





this.context is used when we're accessing a single context object inside a component


Consumer is used anytime we want to get access to multiple different context objects inside a single component e.g say we had another context object in color and we wanted to use both color and language context objects in Button. we can't use this.context in this case



create a new file called ColorContext.  we dont have to pass the default value as we will pass the value in our Provider component

import React from "react";

export default React.createContext()


App.js

        <ColorContext.Provider value="red">
            <LanguageContext.Provider value={this.state.language}>
                <UserCreate/>
            </LanguageContext.Provider>
        </ColorContext.Provider>

it doesn't matter how you nest your components. either can come first


Button.js

    <ColorContext.Consumer>
        {(color) =>
            <button className={`ui button ${color}`}>
                <LanguageContext.Consumer>
                    {(value) => value === "english" ? "Submit" : "Voorlegen"}
                </LanguageContext.Consumer>
            </button>
        }
    </ColorContext.Consumer>


the child of a consumer should be a function, we will transfer the code into this function





